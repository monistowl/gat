/// PFDelta dataset loader for power flow benchmark instances
///
/// PFDelta (https://github.com/MOSSLab-MIT/pfdelta) is a comprehensive benchmark
/// containing 859,800 solved power flow instances across IEEE standard test cases
/// (14/30/57/118-bus and GOC 500/2000-bus) with N, N-1, and N-2 contingencies.
///
/// This module provides utilities to load PFDelta JSON instances and convert them
/// to GAT's Network representation for AC OPF solving and reliability analysis.
use anyhow::{anyhow, Context, Result};
use gat_core::{Branch, BranchId, Bus, BusId, Edge, Gen, GenId, Load, LoadId, Network, Node, Shunt, ShuntId};
use serde_json::Value;
use std::collections::HashMap;
use std::fs;
use std::path::Path;

/// PFDelta test case metadata
#[derive(Debug, Clone)]
pub struct PFDeltaTestCase {
    /// Case name (e.g., "case57")
    pub case_name: String,
    /// Contingency type: "n", "n-1", or "n-2"
    pub contingency_type: String,
    /// Path to the JSON file
    pub file_path: String,
    /// Whether this is a near-infeasible case
    pub is_near_infeasible: bool,
}

/// Reference power flow solution from PFΔ dataset
#[derive(Debug, Clone, Default)]
pub struct PFDeltaSolution {
    /// Bus voltage magnitudes (bus_id -> Vm in p.u.)
    pub vm: HashMap<usize, f64>,
    /// Bus voltage angles (bus_id -> Va in radians)
    pub va: HashMap<usize, f64>,
    /// Generator active power outputs (gen_id -> P in MW)
    pub pgen: HashMap<usize, f64>,
    /// Generator reactive power outputs (gen_id -> Q in MVAr)
    pub qgen: HashMap<usize, f64>,
    /// Objective value from the solved case
    pub objective: f64,
}

/// Complete PFΔ instance with network and reference solution
#[derive(Debug)]
pub struct PFDeltaInstance {
    /// Test case metadata
    pub test_case: PFDeltaTestCase,
    /// GAT network representation
    pub network: Network,
    /// Reference solution from the dataset
    pub solution: PFDeltaSolution,
}

/// Load a single PFDelta JSON test case and convert to GAT Network
pub fn load_pfdelta_case(json_path: &Path) -> Result<Network> {
    let json_content = fs::read_to_string(json_path)
        .with_context(|| format!("reading PFDelta JSON: {}", json_path.display()))?;

    let data: Value = serde_json::from_str(&json_content)
        .with_context(|| format!("parsing PFDelta JSON: {}", json_path.display()))?;

    // PFDelta JSON has structure: { "network": {...}, "solution": {...} }
    let network_data = data
        .get("network")
        .ok_or_else(|| anyhow!("No 'network' field in PFDelta JSON"))?;

    convert_pfdelta_to_network(network_data)
}

/// Load a PFDelta JSON file and return network with reference solution
///
/// For power flow validation, this loads the network with the **solved** generator
/// dispatch (from solution.solution.gen), not the initial dispatch. This ensures
/// GAT's PF solver produces the same voltages as the reference solution.
pub fn load_pfdelta_instance(
    json_path: &Path,
    test_case: &PFDeltaTestCase,
) -> Result<PFDeltaInstance> {
    let json_content = fs::read_to_string(json_path)
        .with_context(|| format!("reading PFDelta JSON: {}", json_path.display()))?;

    let data: Value = serde_json::from_str(&json_content)
        .with_context(|| format!("parsing PFDelta JSON: {}", json_path.display()))?;

    // PFDelta JSON has structure: { "network": {...}, "solution": {...} }
    let network_data = data
        .get("network")
        .ok_or_else(|| anyhow!("No 'network' field in PFDelta JSON"))?;

    let mut network = convert_pfdelta_to_network(network_data)?;
    let solution = extract_pfdelta_solution(&data)?;

    // Apply solved generator dispatch to network for PF validation
    // This ensures we're solving the same problem as the reference
    apply_solved_dispatch(&mut network, &data)?;

    Ok(PFDeltaInstance {
        test_case: test_case.clone(),
        network,
        solution,
    })
}

/// Apply solved generator dispatch from solution to network
///
/// For PF validation, we need to use the solved Pg/Qg values as inputs,
/// not the initial dispatch from the network section. We also need to
/// use the reference solution's bus voltages as generator setpoints,
/// since the reference was generated by an OPF solver.
fn apply_solved_dispatch(network: &mut Network, data: &Value) -> Result<()> {
    let sol_data = data.get("solution").and_then(|s| s.get("solution"));
    let Some(sol) = sol_data else {
        return Ok(()); // No solution data, keep original dispatch
    };

    let Some(gen_solutions) = sol["gen"].as_object() else {
        return Ok(());
    };

    // Check if solution data is in per-unit (inherits from network)
    // The solution section also has per_unit flag
    let is_per_unit = sol["per_unit"]
        .as_bool()
        .or_else(|| data["network"]["per_unit"].as_bool())
        .unwrap_or(false);
    let base_mva = sol["baseMVA"]
        .as_f64()
        .or_else(|| data["network"]["baseMVA"].as_f64())
        .unwrap_or(100.0);
    let power_scale = if is_per_unit { base_mva } else { 1.0 };

    // Build a map of solved dispatch values (scaled to MW/MVAr)
    let mut solved_pg: std::collections::HashMap<usize, f64> = std::collections::HashMap::new();
    let mut solved_qg: std::collections::HashMap<usize, f64> = std::collections::HashMap::new();

    for (gen_idx_str, gen_data) in gen_solutions {
        let gen_idx: usize = gen_idx_str.parse().unwrap_or(0);
        if let Some(pg) = gen_data["pg"].as_f64() {
            solved_pg.insert(gen_idx, pg * power_scale);
        }
        if let Some(qg) = gen_data["qg"].as_f64() {
            solved_qg.insert(gen_idx, qg * power_scale);
        }
    }

    // Build a map of bus_id -> reference voltage from solution.solution.bus
    let mut ref_bus_vm: std::collections::HashMap<usize, f64> = std::collections::HashMap::new();
    if let Some(bus_solutions) = sol["bus"].as_object() {
        for (bus_idx_str, bus_data) in bus_solutions {
            let bus_idx: usize = bus_idx_str.parse().unwrap_or(0);
            if let Some(vm) = bus_data["vm"].as_f64() {
                ref_bus_vm.insert(bus_idx, vm);
            }
        }
    }

    // Build a map of gen_id -> gen_bus from network.gen
    let mut gen_bus_map: std::collections::HashMap<usize, usize> = std::collections::HashMap::new();
    if let Some(network_gens) = data["network"]["gen"].as_object() {
        for (gen_idx_str, gen_data) in network_gens {
            let gen_idx: usize = gen_idx_str.parse().unwrap_or(0);
            let gen_bus = gen_data["gen_bus"]
                .as_u64()
                .or_else(|| gen_data["bus"].as_u64())
                .unwrap_or(0) as usize;
            gen_bus_map.insert(gen_idx, gen_bus);
        }
    }

    // Apply to network generators
    for node in network.graph.node_weights_mut() {
        if let Node::Gen(gen) = node {
            let gen_id = gen.id.value();
            if let Some(&pg) = solved_pg.get(&gen_id) {
                gen.active_power_mw = pg;
            }
            if let Some(&qg) = solved_qg.get(&gen_id) {
                gen.reactive_power_mvar = qg;
            }
            // Set voltage setpoint from reference solution's bus voltage
            if let Some(&gen_bus) = gen_bus_map.get(&gen_id) {
                if let Some(&ref_vm) = ref_bus_vm.get(&gen_bus) {
                    gen.voltage_setpoint_pu = Some(ref_vm);
                }
            }
        }
    }

    Ok(())
}

/// Extract reference solution from PFDelta JSON
fn extract_pfdelta_solution(data: &Value) -> Result<PFDeltaSolution> {
    let mut solution = PFDeltaSolution::default();

    // Get objective from solution metadata
    if let Some(obj) = data["solution"]["objective"].as_f64() {
        solution.objective = obj;
    }

    // Extract solved values from solution.solution (nested)
    let sol_data = data.get("solution").and_then(|s| s.get("solution"));

    if let Some(sol) = sol_data {
        // Extract bus voltages
        if let Some(buses) = sol["bus"].as_object() {
            for (bus_idx_str, bus_data) in buses {
                let bus_idx: usize = bus_idx_str.parse().unwrap_or(0);

                if let Some(vm) = bus_data["vm"].as_f64() {
                    solution.vm.insert(bus_idx, vm);
                }
                if let Some(va) = bus_data["va"].as_f64() {
                    solution.va.insert(bus_idx, va);
                }
            }
        }

        // Extract generator outputs
        if let Some(gens) = sol["gen"].as_object() {
            for (gen_idx_str, gen_data) in gens {
                let gen_idx: usize = gen_idx_str.parse().unwrap_or(0);

                if let Some(pg) = gen_data["pg"].as_f64() {
                    solution.pgen.insert(gen_idx, pg);
                }
                if let Some(qg) = gen_data["qg"].as_f64() {
                    solution.qgen.insert(gen_idx, qg);
                }
            }
        }
    }

    Ok(solution)
}

/// Convert PFDelta JSON structure to GAT Network
fn convert_pfdelta_to_network(data: &Value) -> Result<Network> {
    let mut network = Network::new();

    // Check if data is in per-unit and get baseMVA for scaling
    // PFDelta data has per_unit: true and all power values normalized by baseMVA
    let is_per_unit = data["per_unit"].as_bool().unwrap_or(false);
    let base_mva = data["baseMVA"].as_f64().unwrap_or(100.0);

    // Scale factor: multiply per-unit values by baseMVA to get MW/MVAr
    let power_scale = if is_per_unit { base_mva } else { 1.0 };

    // Extract buses
    let buses = data["bus"]
        .as_object()
        .ok_or_else(|| anyhow!("No 'bus' field in PFDelta JSON"))?;

    // Create a mapping from bus index to NodeIndex
    let mut bus_node_map: HashMap<usize, gat_core::NodeIndex> = HashMap::new();

    for (bus_idx_str, bus_data) in buses {
        let bus_idx: usize = bus_idx_str
            .parse()
            .with_context(|| format!("Invalid bus index: {}", bus_idx_str))?;

        let bus_name = format!("bus_{}", bus_idx);
        // Try base_kv first (actual PFDelta format), fall back to vn
        let voltage_kv = bus_data["base_kv"]
            .as_f64()
            .or_else(|| bus_data["vn"].as_f64())
            .unwrap_or(100.0);

        let node_idx = network.graph.add_node(Node::Bus(Bus {
            id: BusId::new(bus_idx),
            name: bus_name,
            voltage_kv,
            ..Bus::default()
        }));

        bus_node_map.insert(bus_idx, node_idx);
    }

    // Find the slack bus (bus_type = 3) from bus data
    let slack_bus_id: Option<usize> = buses
        .iter()
        .filter_map(|(bus_idx_str, bus_data)| {
            let bus_type = bus_data["bus_type"].as_u64().unwrap_or(1);
            if bus_type == 3 {
                bus_idx_str.parse::<usize>().ok()
            } else {
                None
            }
        })
        .next();

    // Extract generators - sort by bus ID to ensure slack bus generator is added first
    // GAT's power flow solver picks the first generator as slack, so ordering matters
    let gen_data = data["gen"].as_object();
    if let Some(generators) = gen_data {
        // Collect and sort generators: slack bus first, then by bus ID
        let mut gen_list: Vec<_> = generators.iter().collect();
        gen_list.sort_by(|(_, gen_a), (_, gen_b)| {
            let bus_a = gen_a["gen_bus"]
                .as_u64()
                .or_else(|| gen_a["bus"].as_u64())
                .unwrap_or(0) as usize;
            let bus_b = gen_b["gen_bus"]
                .as_u64()
                .or_else(|| gen_b["bus"].as_u64())
                .unwrap_or(0) as usize;

            // Slack bus generator should come first
            let is_slack_a = slack_bus_id == Some(bus_a);
            let is_slack_b = slack_bus_id == Some(bus_b);

            match (is_slack_a, is_slack_b) {
                (true, false) => std::cmp::Ordering::Less,
                (false, true) => std::cmp::Ordering::Greater,
                _ => bus_a.cmp(&bus_b),
            }
        });

        for (gen_idx_str, gen) in gen_list {
            // Skip offline generators (gen_status=0 means out of service)
            let gen_status = gen["gen_status"].as_i64().unwrap_or(1);
            if gen_status == 0 {
                continue;
            }

            let gen_idx: usize = gen_idx_str
                .parse()
                .with_context(|| format!("Invalid gen index: {}", gen_idx_str))?;

            // Try gen_bus first (actual PFDelta format), fall back to bus
            let bus_id = gen["gen_bus"]
                .as_u64()
                .or_else(|| gen["bus"].as_u64())
                .unwrap_or(0) as usize;

            // Power values - scale from per-unit to MW/MVAr if needed
            let pg = gen["pg"].as_f64().unwrap_or(0.0) * power_scale;
            let qg = gen["qg"].as_f64().unwrap_or(0.0) * power_scale;
            let pmin = gen["pmin"].as_f64().unwrap_or(0.0) * power_scale;
            let pmax_raw = gen["pmax"].as_f64();
            let pmax = pmax_raw.map_or(f64::INFINITY, |v| v * power_scale);
            let qmin_raw = gen["qmin"].as_f64();
            let qmin = qmin_raw.map_or(f64::NEG_INFINITY, |v| v * power_scale);
            let qmax_raw = gen["qmax"].as_f64();
            let qmax = qmax_raw.map_or(f64::INFINITY, |v| v * power_scale);

            let gen_name = format!("gen_{}", gen_idx);

            network.graph.add_node(Node::Gen(Gen {
                id: GenId::new(gen_idx),
                name: gen_name,
                bus: BusId::new(bus_id),
                active_power_mw: pg,
                reactive_power_mvar: qg,
                pmin_mw: pmin,
                pmax_mw: pmax,
                qmin_mvar: qmin,
                qmax_mvar: qmax,
                cost_model: gat_core::CostModel::NoCost,
                is_synchronous_condenser: false,
                ..Gen::default()
            }));
        }
    }

    // Extract loads
    let load_data = data["load"].as_object();
    if let Some(loads) = load_data {
        for (load_idx_str, load) in loads {
            let load_idx: usize = load_idx_str
                .parse()
                .with_context(|| format!("Invalid load index: {}", load_idx_str))?;

            // Try load_bus first (actual PFDelta format), fall back to bus
            let bus_id = load["load_bus"]
                .as_u64()
                .or_else(|| load["bus"].as_u64())
                .unwrap_or(0) as usize;

            // Power values - scale from per-unit to MW/MVAr if needed
            let pd = load["pd"].as_f64().unwrap_or(0.0) * power_scale;
            let qd = load["qd"].as_f64().unwrap_or(0.0) * power_scale;

            let load_name = format!("load_{}", load_idx);

            network.graph.add_node(Node::Load(Load {
                id: LoadId::new(load_idx),
                name: load_name,
                bus: BusId::new(bus_id),
                active_power_mw: pd,
                reactive_power_mvar: qd,
            }));
        }
    }

    // Extract branches (transmission lines)
    let branch_data = data["branch"].as_object();
    if let Some(branches) = branch_data {
        for (branch_idx_str, branch) in branches {
            // Skip outaged branches (br_status=0 means out of service)
            let br_status = branch["br_status"].as_i64().unwrap_or(1);
            if br_status == 0 {
                continue;
            }

            let branch_idx: usize = branch_idx_str
                .parse()
                .with_context(|| format!("Invalid branch index: {}", branch_idx_str))?;

            // Try f_bus/t_bus first (actual PFDelta format), fall back to fbus/tbus
            let from_bus_id = branch["f_bus"]
                .as_u64()
                .or_else(|| branch["fbus"].as_u64())
                .unwrap_or(0) as usize;

            let to_bus_id = branch["t_bus"]
                .as_u64()
                .or_else(|| branch["tbus"].as_u64())
                .unwrap_or(0) as usize;

            // Try br_r/br_x first (actual PFDelta format), fall back to r/x
            let r = branch["br_r"]
                .as_f64()
                .or_else(|| branch["r"].as_f64())
                .unwrap_or(0.0);
            let x = branch["br_x"]
                .as_f64()
                .or_else(|| branch["x"].as_f64())
                .unwrap_or(0.01);

            // Line charging susceptance (total = b_fr + b_to)
            let b_fr = branch["b_fr"].as_f64().unwrap_or(0.0);
            let b_to = branch["b_to"].as_f64().unwrap_or(0.0);
            let charging_b = b_fr + b_to;

            // Transformer tap ratio (1.0 for transmission lines)
            let tap = branch["tap"].as_f64().unwrap_or(1.0);
            // Handle tap=0 which means 1.0 (no transformation)
            let tap_ratio = if tap == 0.0 { 1.0 } else { tap };

            // Phase shift in radians
            let shift = branch["shift"].as_f64().unwrap_or(0.0);

            // Thermal ratings
            let rate_a = branch["rate_a"].as_f64();
            let rate_b = branch["rate_b"].as_f64();
            let rate_c = branch["rate_c"].as_f64();

            let branch_name = format!("br_{}_{}", from_bus_id, to_bus_id);

            // Find node indices for the buses
            if let (Some(&from_idx), Some(&to_idx)) =
                (bus_node_map.get(&from_bus_id), bus_node_map.get(&to_bus_id))
            {
                network.graph.add_edge(
                    from_idx,
                    to_idx,
                    Edge::Branch(Branch {
                        id: BranchId::new(branch_idx),
                        name: branch_name,
                        from_bus: BusId::new(from_bus_id),
                        to_bus: BusId::new(to_bus_id),
                        resistance: r,
                        reactance: x,
                        charging_b_pu: charging_b,
                        tap_ratio,
                        phase_shift_rad: shift,
                        rating_a_mva: rate_a,
                        rating_b_mva: rate_b,
                        rating_c_mva: rate_c,
                        ..Branch::default()
                    }),
                );
            }
        }
    }

    // Extract shunt elements (capacitors/reactors)
    let shunt_data = data["shunt"].as_object();
    if let Some(shunts) = shunt_data {
        for (shunt_idx_str, shunt) in shunts {
            // Skip offline shunts
            let status = shunt["status"].as_i64().unwrap_or(1);
            if status == 0 {
                continue;
            }

            let shunt_idx: usize = shunt_idx_str
                .parse()
                .with_context(|| format!("Invalid shunt index: {}", shunt_idx_str))?;

            let bus_id = shunt["shunt_bus"]
                .as_u64()
                .or_else(|| shunt["bus"].as_u64())
                .unwrap_or(0) as usize;

            // Shunt conductance and susceptance (already in per-unit)
            let gs = shunt["gs"].as_f64().unwrap_or(0.0);
            let bs = shunt["bs"].as_f64().unwrap_or(0.0);

            let shunt_name = format!("shunt_{}", shunt_idx);

            network.graph.add_node(Node::Shunt(Shunt {
                id: ShuntId::new(shunt_idx),
                name: shunt_name,
                bus: BusId::new(bus_id),
                gs_pu: gs,
                bs_pu: bs,
                status: true,
            }));
        }
    }

    Ok(network)
}

/// List available PFDelta test cases in a directory
pub fn list_pfdelta_cases(pfdelta_root: &Path) -> Result<Vec<PFDeltaTestCase>> {
    let mut cases = Vec::new();

    // Expected structure: pfdelta_root/case{14,30,57,118,500,2000}/{n,n-1,n-2}/raw/
    for entry in fs::read_dir(pfdelta_root)
        .with_context(|| format!("reading PFDelta directory: {}", pfdelta_root.display()))?
    {
        let entry = entry?;
        let path = entry.path();

        if path.is_dir() {
            let case_name = path
                .file_name()
                .and_then(|n| n.to_str())
                .unwrap_or("unknown")
                .to_string();

            // Check for contingency subdirectories
            for cont_type in &["n", "n-1", "n-2"] {
                let raw_dir = path.join(cont_type).join("raw");
                if raw_dir.exists() {
                    // List JSON files in raw directory
                    if let Ok(files) = fs::read_dir(&raw_dir) {
                        for file in files.flatten() {
                            let file_path = file.path();
                            if file_path.extension().is_some_and(|ext| ext == "json") {
                                cases.push(PFDeltaTestCase {
                                    case_name: case_name.clone(),
                                    contingency_type: cont_type.to_string(),
                                    file_path: file_path.display().to_string(),
                                    is_near_infeasible: false,
                                });
                            }
                        }
                    }
                }

                // Also check for near-infeasible cases
                let nose_dir = path.join(cont_type).join("nose");
                if nose_dir.exists() {
                    if let Ok(files) = fs::read_dir(&nose_dir) {
                        for file in files.flatten() {
                            let file_path = file.path();
                            if file_path.extension().is_some_and(|ext| ext == "json") {
                                cases.push(PFDeltaTestCase {
                                    case_name: case_name.clone(),
                                    contingency_type: format!("{}_nose", cont_type),
                                    file_path: file_path.display().to_string(),
                                    is_near_infeasible: true,
                                });
                            }
                        }
                    }
                }
            }
        }
    }

    Ok(cases)
}

/// Batch load multiple PFDelta test cases
pub fn load_pfdelta_batch(
    test_cases: &[PFDeltaTestCase],
    max_count: Option<usize>,
) -> Result<Vec<(PFDeltaTestCase, Network)>> {
    let limit = max_count.unwrap_or(test_cases.len());
    let mut loaded = Vec::new();

    for (i, test_case) in test_cases.iter().take(limit).enumerate() {
        match load_pfdelta_case(Path::new(&test_case.file_path)) {
            Ok(network) => {
                loaded.push((test_case.clone(), network));
            }
            Err(e) => {
                eprintln!(
                    "Warning: Failed to load test case {} ({}): {}",
                    i, test_case.file_path, e
                );
            }
        }
    }

    Ok(loaded)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_pfdelta_json_parsing() {
        // Create a minimal valid PFDelta JSON structure
        let json_str = r#"{
            "bus": {
                "1": {"vn": 100.0},
                "2": {"vn": 100.0}
            },
            "gen": {
                "1": {"bus": 1, "pg": 100.0, "qg": 50.0}
            },
            "load": {
                "1": {"bus": 2, "pd": 80.0, "qd": 40.0}
            },
            "branch": {
                "1": {"fbus": 1, "tbus": 2, "r": 0.01, "x": 0.05}
            }
        }"#;

        let data: Value = serde_json::from_str(json_str).unwrap();
        let network = convert_pfdelta_to_network(&data).unwrap();

        // Should have 4 nodes: 2 buses + 1 gen + 1 load
        assert_eq!(network.graph.node_count(), 4);
        // Should have 1 branch edge
        assert_eq!(network.graph.edge_count(), 1);
    }
}
