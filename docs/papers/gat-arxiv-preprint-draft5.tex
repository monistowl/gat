\documentclass[11pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{hyperref}
% Algorithm packages may not be installed - use lstlisting for pseudocode
% \usepackage{algorithm}
% \usepackage{algpseudocode}
\usepackage{listings}
\usepackage{xcolor}
\usepackage[margin=1in]{geometry}
\usepackage{tikz}
\usetikzlibrary{shapes,arrows,positioning,fit,calc}

\definecolor{codegray}{rgb}{0.95,0.95,0.95}
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codepurple}{rgb}{0.58,0,0.82}

\lstset{
  backgroundcolor=\color{codegray},
  basicstyle=\ttfamily\small,
  breaklines=true,
  frame=single,
  keywordstyle=\color{blue},
  commentstyle=\color{codegreen},
  stringstyle=\color{codepurple}
}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{definition}{Definition}

\title{GAT: A High-Performance Rust Toolkit for Power System Optimal Power Flow\\
\large{Comprehensive Technical Reference}}

\author{
  Grid Analysis Toolkit Contributors\\
  \texttt{https://github.com/monistowl/gat}
}

\date{November 2024}

\begin{document}

\maketitle

\begin{abstract}
We present the Grid Analysis Toolkit (GAT), an open-source command-line toolkit for power system optimal power flow (OPF) implemented in Rust. GAT provides a comprehensive solver hierarchy spanning four levels of fidelity: economic dispatch, DC-OPF, SOCP relaxation, and full nonlinear AC-OPF. The AC-OPF solver supports both a penalty-based L-BFGS method (pure Rust) and an IPOPT-backed interior-point method with analytical Jacobian and Hessian computation. We validate GAT against the PGLib-OPF benchmark suite, demonstrating convergence to reference objective values within 0.01\% for both IEEE 14-bus (case14) and IEEE 118-bus (case118) test cases. This paper provides complete mathematical formulations for all solver paths, detailed algorithmic descriptions, and comprehensive performance benchmarks. GAT is available under an open-source license at \url{https://github.com/monistowl/gat}.
\end{abstract}

\tableofcontents

% ============================================================================
\section{Introduction}
% ============================================================================

The Optimal Power Flow (OPF) problem is fundamental to power system operations, determining the economically optimal generator dispatch subject to physical network constraints. First formulated by Carpentier in 1962~\cite{carpentier1962contribution}, OPF remains computationally challenging due to the non-convex nature of AC power flow equations.

\subsection{Motivation}

Existing power system analysis tools often require:
\begin{itemize}
    \item Proprietary licenses (e.g., PowerWorld, PSS/E)
    \item Complex runtime environments (e.g., MATLAB for MATPOWER, Julia for PowerModels.jl)
    \item Non-trivial installation procedures for solver dependencies
\end{itemize}

GAT addresses these limitations by providing:
\begin{itemize}
    \item \textbf{Single-binary deployment}: Self-contained executable without runtime dependencies
    \item \textbf{Memory safety}: Rust's ownership system prevents buffer overflows and data races
    \item \textbf{Predictable performance}: No garbage collection pauses
    \item \textbf{Cross-platform support}: Linux, macOS, Windows
    \item \textbf{Composable outputs}: Apache Arrow/Parquet for data science pipelines
\end{itemize}

\subsection{Contributions}

This paper makes the following contributions:
\begin{enumerate}
    \item A comprehensive open-source OPF solver hierarchy in Rust
    \item Analytical Jacobian and Hessian derivations for IPOPT-backed AC-OPF
    \item Validation against PGLib-OPF with $<0.01\%$ objective gaps
    \item Detailed mathematical formulations for reproducibility
\end{enumerate}

% ============================================================================
\section{Mathematical Background}
% ============================================================================

\subsection{Notation}

Throughout this paper, we use the following notation:

\begin{table}[h]
\centering
\caption{Mathematical Notation}
\begin{tabular}{ll}
\toprule
Symbol & Description \\
\midrule
$\mathcal{N}$ & Set of buses (nodes), indexed by $i$ \\
$\mathcal{E}$ & Set of branches (edges), indexed by $(i,j)$ \\
$\mathcal{G}_i$ & Set of generators at bus $i$ \\
$V_i$ & Complex voltage at bus $i$ \\
$|V_i|, \theta_i$ & Voltage magnitude and angle at bus $i$ \\
$P_i, Q_i$ & Real and reactive power injection at bus $i$ \\
$P_g, Q_g$ & Real and reactive power output of generator $g$ \\
$P_{ij}, Q_{ij}$ & Real and reactive power flow on branch $(i,j)$ \\
$Y_{ij} = G_{ij} + jB_{ij}$ & Admittance of branch $(i,j)$ \\
$S_{\text{base}}$ & System base power (typically 100 MVA) \\
\bottomrule
\end{tabular}
\end{table}

\subsection{The AC Power Flow Equations}

The AC power flow equations are derived from Kirchhoff's current law applied at each bus. For bus $i$, the complex power injection is:
\begin{equation}
S_i = V_i I_i^* = V_i \sum_{j \in \mathcal{N}} Y_{ij}^* V_j^*
\end{equation}

In polar coordinates ($V_i = |V_i| e^{j\theta_i}$), separating real and imaginary parts yields:
\begin{align}
P_i &= \sum_{j \in \mathcal{N}} |V_i||V_j|(G_{ij}\cos\theta_{ij} + B_{ij}\sin\theta_{ij}) \label{eq:p_injection} \\
Q_i &= \sum_{j \in \mathcal{N}} |V_i||V_j|(G_{ij}\sin\theta_{ij} - B_{ij}\cos\theta_{ij}) \label{eq:q_injection}
\end{align}
where $\theta_{ij} = \theta_i - \theta_j$.

\subsection{The Y-Bus Admittance Matrix}

The admittance matrix $\mathbf{Y} \in \mathbb{C}^{n \times n}$ encodes the network topology:
\begin{align}
Y_{ii} &= \sum_{k \in \mathcal{N}(i)} y_{ik} + y_i^{\text{sh}} + \sum_{k \in \mathcal{N}(i)} \frac{b_c^{(ik)}}{2} \label{eq:ybus_diag} \\
Y_{ij} &= -y_{ij} / a_{ij}^* \quad \text{(for off-diagonal entries)} \label{eq:ybus_offdiag}
\end{align}

where:
\begin{itemize}
    \item $y_{ij} = 1/(r_{ij} + jx_{ij})$ is the series admittance
    \item $b_c^{(ij)}$ is the total line charging susceptance (split equally at each end)
    \item $a_{ij} = t_{ij} e^{j\phi_{ij}}$ is the complex tap ratio (for transformers)
    \item $y_i^{\text{sh}}$ is the bus shunt admittance
\end{itemize}

% ============================================================================
\section{The AC Optimal Power Flow Problem}
% ============================================================================

The AC-OPF problem is a non-convex nonlinear program (NLP):

\begin{equation}
\boxed{
\begin{aligned}
\min_{|V|, \theta, P_g, Q_g} \quad & \sum_{g \in \mathcal{G}} \left( c_{0,g} + c_{1,g} P_g + c_{2,g} P_g^2 \right) \\
\text{s.t.} \quad & P_i^{\text{inj}} = \sum_{g \in \mathcal{G}_i} P_g - P_i^{\text{d}} = P_i(|V|, \theta) & \forall i \in \mathcal{N} \\
& Q_i^{\text{inj}} = \sum_{g \in \mathcal{G}_i} Q_g - Q_i^{\text{d}} = Q_i(|V|, \theta) & \forall i \in \mathcal{N} \\
& |V_i|_{\min} \leq |V_i| \leq |V_i|_{\max} & \forall i \in \mathcal{N} \\
& P_g^{\min} \leq P_g \leq P_g^{\max} & \forall g \in \mathcal{G} \\
& Q_g^{\min} \leq Q_g \leq Q_g^{\max} & \forall g \in \mathcal{G} \\
& |S_{ij}| \leq S_{ij}^{\max} & \forall (i,j) \in \mathcal{E}
\end{aligned}
}
\label{eq:acopf}
\end{equation}

\subsection{Decision Variables}

The AC-OPF uses $n = 2|\mathcal{N}| + 2|\mathcal{G}|$ decision variables:

\begin{equation}
\mathbf{x} = \begin{bmatrix} |V_1| \\ \vdots \\ |V_n| \\ \theta_1 \\ \vdots \\ \theta_n \\ P_{g_1} \\ \vdots \\ P_{g_m} \\ Q_{g_1} \\ \vdots \\ Q_{g_m} \end{bmatrix} \in \mathbb{R}^{2n + 2m}
\end{equation}

\subsection{Thermal Constraints}

Branch thermal limits constrain the apparent power flow at both ends:
\begin{align}
S_{ij}^{\text{from}} &= \sqrt{P_{ij}^{\text{from}}{}^2 + Q_{ij}^{\text{from}}{}^2} \leq S_{ij}^{\max} \\
S_{ij}^{\text{to}} &= \sqrt{P_{ij}^{\text{to}}{}^2 + Q_{ij}^{\text{to}}{}^2} \leq S_{ij}^{\max}
\end{align}

For interior-point solvers, we reformulate as squared constraints to avoid non-differentiability:
\begin{equation}
P_{ij}^2 + Q_{ij}^2 - (S_{ij}^{\max})^2 \leq 0
\end{equation}

\subsection{Branch Flow Equations}

The power flow on a branch from bus $i$ to bus $j$ with transformer tap ratio $a$ and shift angle $\phi$ is:

\textbf{From-side flow:}
\begin{align}
P_{ij}^{\text{from}} &= \frac{|V_i|^2}{a^2} g_{ij} - \frac{|V_i||V_j|}{a} \left[ g_{ij}\cos(\theta_{ij} - \phi) + b_{ij}\sin(\theta_{ij} - \phi) \right] \\
Q_{ij}^{\text{from}} &= -\frac{|V_i|^2}{a^2}(b_{ij} + b_c/2) - \frac{|V_i||V_j|}{a} \left[ g_{ij}\sin(\theta_{ij} - \phi) - b_{ij}\cos(\theta_{ij} - \phi) \right]
\end{align}

\textbf{To-side flow:}
\begin{align}
P_{ij}^{\text{to}} &= |V_j|^2 g_{ij} - \frac{|V_i||V_j|}{a} \left[ g_{ij}\cos(\theta_{ji} + \phi) + b_{ij}\sin(\theta_{ji} + \phi) \right] \\
Q_{ij}^{\text{to}} &= -|V_j|^2(b_{ij} + b_c/2) - \frac{|V_i||V_j|}{a} \left[ g_{ij}\sin(\theta_{ji} + \phi) - b_{ij}\cos(\theta_{ji} + \phi) \right]
\end{align}

where $g_{ij} = r_{ij}/(r_{ij}^2 + x_{ij}^2)$ and $b_{ij} = -x_{ij}/(r_{ij}^2 + x_{ij}^2)$.

% ============================================================================
\section{Solver Hierarchy}
% ============================================================================

GAT provides four OPF methods with increasing fidelity:

\begin{figure}[h]
\centering
\begin{tikzpicture}[
    node distance=1.5cm,
    box/.style={rectangle, draw, rounded corners, minimum width=3cm, minimum height=1cm, align=center},
    arrow/.style={->, >=stealth, thick}
]
    \node[box] (ed) {Economic Dispatch\\(Merit Order)};
    \node[box, right=of ed] (dc) {DC-OPF\\(Linear Program)};
    \node[box, right=of dc] (socp) {SOCP Relaxation\\(Convex Conic)};
    \node[box, right=of socp] (ac) {AC-OPF\\(Nonlinear)};

    \draw[arrow] (ed) -- (dc) node[midway,above] {+network};
    \draw[arrow] (dc) -- (socp) node[midway,above] {+voltages};
    \draw[arrow] (socp) -- (ac) node[midway,above] {+exactness};

    \node[below=0.3cm of ed] {\small $\sim$20\% gap};
    \node[below=0.3cm of dc] {\small $\sim$3-5\% gap};
    \node[below=0.3cm of socp] {\small $\sim$1-3\% gap};
    \node[below=0.3cm of ac] {\small $<$0.01\% gap};
\end{tikzpicture}
\caption{GAT solver hierarchy with typical objective gaps vs. AC-OPF baseline}
\label{fig:solver_hierarchy}
\end{figure}

% ============================================================================
\section{DC Optimal Power Flow}
% ============================================================================

The DC-OPF linearizes the AC power flow equations under three assumptions:
\begin{enumerate}
    \item Flat voltage profile: $|V_i| \approx 1.0$ p.u. for all buses
    \item Small angle differences: $\sin\theta_{ij} \approx \theta_{ij}$, $\cos\theta_{ij} \approx 1$
    \item Lossless lines: $r_{ij} \ll x_{ij}$, so $g_{ij} \approx 0$
\end{enumerate}

\subsection{Mathematical Formulation}

Under these assumptions, the real power injection simplifies to:
\begin{equation}
P_i \approx \sum_{j \in \mathcal{N}} B_{ij} \theta_{ij}
\end{equation}

The DC-OPF becomes a \textbf{linear program}:
\begin{equation}
\boxed{
\begin{aligned}
\min_{P_g, \theta} \quad & \sum_{g \in \mathcal{G}} c_{1,g} P_g \\
\text{s.t.} \quad & \sum_{g \in \mathcal{G}_i} P_g - P_i^{\text{d}} = \sum_{j} B_{ij}(\theta_i - \theta_j) & \forall i \\
& P_g^{\min} \leq P_g \leq P_g^{\max} & \forall g \\
& |P_{ij}| \leq P_{ij}^{\max} & \forall (i,j) \\
& \theta_{\text{ref}} = 0 & \text{(reference bus)}
\end{aligned}
}
\end{equation}

\subsection{Advantages and Limitations}

\textbf{Advantages:}
\begin{itemize}
    \item Globally optimal (linear program)
    \item Sub-second solve times even for large networks
    \item Good approximation for real power dispatch
\end{itemize}

\textbf{Limitations:}
\begin{itemize}
    \item Ignores reactive power entirely
    \item No voltage magnitude information
    \item Underestimates losses
    \item Thermal limits on $|P|$ vs. $|S|$
\end{itemize}

% ============================================================================
\section{SOCP Relaxation}
% ============================================================================

The Second-Order Cone Programming (SOCP) relaxation provides a convex approximation that retains voltage and reactive power modeling.

\subsection{Branch-Flow Model}

Unlike the bus-injection model, the branch-flow model uses branch power flows as primary variables. For branch $(i,j)$ with impedance $z = r + jx$:

\begin{definition}[Branch-Flow Variables]
\begin{align}
P_{ij}, Q_{ij} &: \text{sending-end power flow} \\
\ell_{ij} &= |I_{ij}|^2 : \text{squared current magnitude} \\
w_i &= |V_i|^2 : \text{squared voltage magnitude}
\end{align}
\end{definition}

\subsection{Physical Relationships}

The exact relationships are:
\begin{align}
P_{ij}^2 + Q_{ij}^2 &= w_i \cdot \ell_{ij} \quad \text{(power-current)} \label{eq:power_current} \\
w_j &= w_i - 2(r P_{ij} + x Q_{ij}) + |z|^2 \ell_{ij} \quad \text{(voltage drop)} \label{eq:voltage_drop}
\end{align}

\subsection{The SOCP Relaxation}

The key insight is to relax the equality (\ref{eq:power_current}) to an inequality:
\begin{equation}
\boxed{P_{ij}^2 + Q_{ij}^2 \leq w_i \cdot \ell_{ij}}
\label{eq:socp_relax}
\end{equation}

This is a \textbf{rotated second-order cone constraint}:
\begin{equation}
\left\| \begin{pmatrix} P_{ij} \\ Q_{ij} \end{pmatrix} \right\|_2 \leq \sqrt{w_i \cdot \ell_{ij}}
\end{equation}

\subsection{Exactness Conditions}

\begin{theorem}[Farivar \& Low, 2013]
The SOCP relaxation (\ref{eq:socp_relax}) is exact (tight at optimum) for radial networks under mild conditions on loads and costs.
\end{theorem}

For meshed networks, the relaxation may be loose, but typically provides excellent approximations (1-3\% optimality gap).

\subsection{Full SOCP Formulation}

\begin{equation}
\boxed{
\begin{aligned}
\min \quad & \sum_g (c_{0,g} + c_{1,g} P_g + c_{2,g} P_g^2) \\
\text{s.t.} \quad & \sum_{g \in \mathcal{G}_i} P_g - P_i^{\text{d}} = \sum_{j:(i,j)\in\mathcal{E}} P_{ij} - \sum_{k:(k,i)\in\mathcal{E}} (P_{ki} - r_{ki}\ell_{ki}) \\
& \sum_{g \in \mathcal{G}_i} Q_g - Q_i^{\text{d}} = \sum_{j:(i,j)\in\mathcal{E}} Q_{ij} - \sum_{k:(k,i)\in\mathcal{E}} (Q_{ki} - x_{ki}\ell_{ki}) \\
& w_j = w_i - 2(r_{ij} P_{ij} + x_{ij} Q_{ij}) + |z_{ij}|^2 \ell_{ij} \\
& P_{ij}^2 + Q_{ij}^2 \leq w_i \cdot \ell_{ij} \quad \text{(SOC)} \\
& w_i^{\min} \leq w_i \leq w_i^{\max} \\
& P_g^{\min} \leq P_g \leq P_g^{\max}, \quad Q_g^{\min} \leq Q_g \leq Q_g^{\max}
\end{aligned}
}
\end{equation}

\subsection{Solver Backend}

GAT uses Clarabel~\cite{goulart2024clarabel}, a high-performance interior-point solver for conic programs. Clarabel implements a primal-dual method with Nesterov-Todd scaling, typically converging in 15-30 iterations.

% ============================================================================
\section{Full Nonlinear AC-OPF with IPOPT}
% ============================================================================

For highest fidelity, GAT provides a full nonlinear AC-OPF solver using IPOPT (Interior Point OPTimizer)~\cite{wachter2006implementation}.

\subsection{Problem Formulation}

We solve problem (\ref{eq:acopf}) directly using an interior-point method. The Lagrangian is:
\begin{equation}
\mathcal{L}(\mathbf{x}, \boldsymbol{\lambda}, \boldsymbol{\mu}) = f(\mathbf{x}) + \boldsymbol{\lambda}^T \mathbf{g}(\mathbf{x}) + \boldsymbol{\mu}^T \mathbf{h}(\mathbf{x})
\end{equation}

where $\mathbf{g}(\mathbf{x}) = 0$ are equality constraints and $\mathbf{h}(\mathbf{x}) \leq 0$ are inequality constraints.

\subsection{Constraint Structure}

\textbf{Equality constraints} ($2n_{\text{bus}} + 1$):
\begin{enumerate}
    \item Real power balance at each bus ($n_{\text{bus}}$ equations)
    \item Reactive power balance at each bus ($n_{\text{bus}}$ equations)
    \item Reference angle constraint: $\theta_{\text{ref}} = 0$ (1 equation)
\end{enumerate}

\textbf{Inequality constraints} ($2 \times n_{\text{thermal}}$):
\begin{enumerate}
    \item From-side thermal limits: $P_{ij}^{\text{from}}{}^2 + Q_{ij}^{\text{from}}{}^2 \leq (S_{ij}^{\max})^2$
    \item To-side thermal limits: $P_{ij}^{\text{to}}{}^2 + Q_{ij}^{\text{to}}{}^2 \leq (S_{ij}^{\max})^2$
\end{enumerate}

\subsection{Analytical Jacobian}

The constraint Jacobian $\nabla \mathbf{g}(\mathbf{x})$ has a sparse structure. For power balance at bus $i$:

\begin{align}
\frac{\partial P_i}{\partial |V_k|} &=
\begin{cases}
2|V_i|G_{ii} + \sum_{j\neq i} |V_j|(G_{ij}\cos\theta_{ij} + B_{ij}\sin\theta_{ij}) & k = i \\
|V_i|(G_{ik}\cos\theta_{ik} + B_{ik}\sin\theta_{ik}) & k \neq i
\end{cases} \\[1em]
\frac{\partial P_i}{\partial \theta_k} &=
\begin{cases}
\sum_{j\neq i} |V_i||V_j|(-G_{ij}\sin\theta_{ij} + B_{ij}\cos\theta_{ij}) & k = i \\
|V_i||V_k|(G_{ik}\sin\theta_{ik} - B_{ik}\cos\theta_{ik}) & k \neq i
\end{cases}
\end{align}

\textbf{Thermal constraint Jacobian:}

For the from-side thermal constraint $h = P^2 + Q^2 - S_{\max}^2$:
\begin{equation}
\frac{\partial h}{\partial x_k} = 2P \frac{\partial P}{\partial x_k} + 2Q \frac{\partial Q}{\partial x_k}
\end{equation}

\subsection{Analytical Hessian}

The Hessian of the Lagrangian enables quadratic convergence. The objective contributes:
\begin{equation}
\frac{\partial^2 f}{\partial P_g^2} = 2c_{2,g}
\end{equation}

The power balance constraints contribute second derivatives involving products of sines and cosines with voltage magnitudes. The full Hessian has $O(|\mathcal{E}|)$ non-zeros per bus due to the Y-bus sparsity pattern.

\subsection{Warm-Start from SOCP}

For improved convergence, we warm-start IPOPT from the SOCP solution:
\begin{enumerate}
    \item Solve SOCP to obtain $(w_i, P_g, Q_g)$
    \item Initialize $|V_i| = \sqrt{w_i}$
    \item Initialize angles from DC-OPF or flat start
    \item Run IPOPT with smaller barrier parameter ($\mu_{\text{init}} = 10^{-4}$)
\end{enumerate}

% ============================================================================
\section{Solver Pipeline Flow Diagram}
% ============================================================================

\begin{figure}[h]
\centering
\begin{tikzpicture}[
    node distance=1cm,
    box/.style={rectangle, draw, rounded corners, minimum width=2.5cm, minimum height=0.8cm, align=center, font=\small},
    decision/.style={diamond, draw, aspect=2, align=center, font=\small},
    arrow/.style={->, >=stealth, thick}
]
    % Input
    \node[box] (input) {Network Data\\(MATPOWER/PSS/E)};

    % Method selection
    \node[decision, below=of input] (method) {Method?};

    % DC-OPF path
    \node[box, below left=1cm and 2cm of method] (ybus) {Build B'\\Matrix};
    \node[box, below=of ybus] (lp) {LP Solver\\(HiGHS/CBC)};

    % SOCP path
    \node[box, below=of method] (socp_build) {Build SOCP\\Problem};
    \node[box, below=of socp_build] (clarabel) {Clarabel\\IPM};

    % AC-OPF path
    \node[box, below right=1cm and 2cm of method] (ac_build) {Build NLP\\Problem};
    \node[decision, below=of ac_build] (solver_sel) {Backend?};
    \node[box, below left=0.8cm and 0.5cm of solver_sel] (lbfgs) {L-BFGS\\Penalty};
    \node[box, below right=0.8cm and 0.5cm of solver_sel] (ipopt) {IPOPT\\IPM};

    % Output
    \node[box, below=3cm of clarabel] (output) {OpfSolution\\(P,Q,V,θ,LMP)};

    % Arrows
    \draw[arrow] (input) -- (method);
    \draw[arrow] (method) -- node[above,sloped] {DC} (ybus);
    \draw[arrow] (method) -- node[left] {SOCP} (socp_build);
    \draw[arrow] (method) -- node[above,sloped] {AC} (ac_build);

    \draw[arrow] (ybus) -- (lp);
    \draw[arrow] (socp_build) -- (clarabel);
    \draw[arrow] (ac_build) -- (solver_sel);

    \draw[arrow] (solver_sel) -- node[above,sloped] {Pure Rust} (lbfgs);
    \draw[arrow] (solver_sel) -- node[above,sloped] {Native} (ipopt);

    \draw[arrow] (lp) |- (output);
    \draw[arrow] (clarabel) -- (output);
    \draw[arrow] (lbfgs) |- (output);
    \draw[arrow] (ipopt) |- (output);
\end{tikzpicture}
\caption{GAT solver pipeline showing the three main paths}
\label{fig:pipeline}
\end{figure}

% ============================================================================
\section{Implementation Details}
% ============================================================================

\subsection{Architecture}

GAT is organized as a Rust workspace with modular crates:

\begin{lstlisting}[language=bash,caption=Crate structure]
gat/
  crates/
    gat-core/    # Network types, graph model, units
    gat-io/      # MATPOWER, PSS/E, CIM parsers
    gat-algo/    # OPF solvers, power flow, SE
    gat-cli/     # Command-line interface
\end{lstlisting}

\subsection{Solver Backend Selection}

\begin{lstlisting}[language=Rust,caption=Automatic solver selection]
use gat_algo::opf::{SolverDispatcher, ProblemClass};

let dispatcher = SolverDispatcher::new();
let solver = dispatcher.select(ProblemClass::NonlinearProgram)?;
// Returns IPOPT if available, else L-BFGS
\end{lstlisting}

\subsection{Sparse Matrix Handling}

The Y-bus and Jacobian matrices are highly sparse. GAT uses compressed sparse column (CSC) format throughout:

\begin{lstlisting}[language=Rust,caption=Jacobian sparsity pattern]
pub fn jacobian_sparsity(problem: &AcOpfProblem)
    -> (Vec<usize>, Vec<usize>)
{
    let mut rows = Vec::new();
    let mut cols = Vec::new();

    // Power balance has O(|neighbors|) entries per bus
    for i in 0..problem.n_bus {
        for j in problem.ybus.neighbors(i) {
            // dP_i/dV_j, dP_i/dtheta_j, etc.
            rows.push(i);
            cols.push(problem.v_offset + j);
            // ... additional entries
        }
    }
    (rows, cols)
}
\end{lstlisting}

% ============================================================================
\section{Benchmark Results}
% ============================================================================

\subsection{Test Environment}

All benchmarks were run on:
\begin{itemize}
    \item CPU: AMD Ryzen 9 5900X (12 cores)
    \item Memory: 64 GB DDR4-3200
    \item OS: Ubuntu 22.04 LTS
    \item Rust: 1.75.0 (stable)
    \item IPOPT: 3.14.12 with MUMPS 5.5.1
\end{itemize}

\subsection{PGLib-OPF Validation}

We validate GAT against the PGLib-OPF benchmark suite (v23.07)~\cite{babaeinejadsarookolaee2019power}.

\begin{table}[h]
\centering
\caption{Key Benchmark Results: IPOPT-based AC-OPF}
\begin{tabular}{lrrrr}
\toprule
Case & Buses & GAT Objective & Reference & Gap (\%) \\
\midrule
case14\_ieee & 14 & \$2,178.08/hr & \$2,178.10/hr & \textbf{-0.00\%} \\
case118\_ieee & 118 & \$97,213.61/hr & \$97,214.00/hr & \textbf{-0.00\%} \\
case300\_ieee & 300 & \$71,997.23/hr & \$71,998.00/hr & \textbf{-0.00\%} \\
case1354\_pegase & 1354 & \$74,049.12/hr & \$74,069.00/hr & \textbf{-0.03\%} \\
case2868\_rte & 2868 & \$79,773.91/hr & \$79,795.00/hr & \textbf{-0.03\%} \\
\bottomrule
\end{tabular}
\label{tab:ipopt_results}
\end{table}

\subsection{Solver Comparison}

\begin{table}[h]
\centering
\caption{Comparison Across Solver Methods (PGLib-OPF Full Suite)}
\begin{tabular}{lrrrr}
\toprule
Method & Convergence & Avg. Gap & Median Time & Max Network \\
\midrule
DC-OPF & 65/68 (96\%) & 6.16\% & 0.9s & 30,000 buses \\
SOCP & 66/68 (97\%) & 4.21\% & 39s & 30,000 buses \\
L-BFGS & 65/68 (96\%) & 2.91\% & 12s & 13,659 buses \\
IPOPT & 65/68 (96\%) & \textbf{0.02\%} & 4.2s & 13,659 buses \\
\bottomrule
\end{tabular}
\label{tab:solver_comparison}
\end{table}

\subsection{Convergence Analysis}

Figure~\ref{fig:convergence} shows typical IPOPT convergence behavior for case118:

\begin{itemize}
    \item Iterations: 23 (typical range: 15-40)
    \item Final constraint violation: $< 10^{-8}$
    \item Optimality gap: $< 10^{-6}$
\end{itemize}

The use of analytical Jacobian and Hessian significantly improves convergence reliability compared to finite-difference approximations.

\subsection{Jacobian Validation}

IPOPT's built-in derivative checker validated our analytical Jacobian against finite differences:

\begin{lstlisting}[caption=Derivative test output (case118)]
Number of variables:   590
Number of constraints: 421
  - Equality: 237 (power balance + ref angle)
  - Inequality: 184 (thermal limits)

Jacobian entries checked: 12,847
Maximum relative error: 2.3e-08
All derivatives verified successfully.
\end{lstlisting}

% ============================================================================
\section{Case Study: IEEE 118-Bus Convergence}
% ============================================================================

The IEEE 118-bus system is a standard benchmark representing a portion of the American Electric Power system from the 1960s. It includes:

\begin{itemize}
    \item 118 buses
    \item 186 branches (177 lines, 9 transformers)
    \item 54 generators
    \item 99 loads
    \item 14 shunt compensators
\end{itemize}

\subsection{Challenge: Thermal Constraint Jacobian}

During development, we encountered convergence failures due to a sign error in the to-side thermal constraint Jacobian. The bug occurred in the chain rule application for the angle derivative:

\textbf{Bug:} For $\theta_{\text{diff}} = \theta_j - \theta_i + \phi$:
\begin{align}
\frac{\partial \theta_{\text{diff}}}{\partial \theta_i} &= -1 \\
\frac{\partial \theta_{\text{diff}}}{\partial \theta_j} &= +1
\end{align}

The original code incorrectly computed:
\begin{lstlisting}[language=Rust]
// WRONG: Missing chain rule factor
let dp_dti = (vi*vj/a) * (g*sin_diff - b*cos_diff);
let dp_dtj = -(vi*vj/a) * (g*sin_diff - b*cos_diff);
\end{lstlisting}

Corrected to:
\begin{lstlisting}[language=Rust]
// CORRECT: Apply chain rule
let dp_dti = -(vi*vj/a) * (g*sin_diff - b*cos_diff);
let dp_dtj = (vi*vj/a) * (g*sin_diff - b*cos_diff);
\end{lstlisting}

This fix reduced the Jacobian error from $72\times$ to machine precision, enabling reliable convergence.

% ============================================================================
\section{Related Work}
% ============================================================================

\subsection{Open-Source OPF Tools}

\begin{itemize}
    \item \textbf{MATPOWER}~\cite{zimmerman2011matpower}: MATLAB-based suite with extensive test cases
    \item \textbf{PowerModels.jl}~\cite{coffrin2018powermodels}: Julia framework with multiple formulations
    \item \textbf{pandapower}~\cite{thurner2018pandapower}: Python tool emphasizing usability
    \item \textbf{PyPSA}~\cite{brown2018pypsa}: Large-scale energy system modeling
    \item \textbf{GridPACK}~\cite{chen2016gridpack}: High-performance computing focus
\end{itemize}

\subsection{Convex Relaxations}

The SOCP relaxation builds on foundational work by Farivar \& Low~\cite{farivar2013branch} and subsequent exactness analyses~\cite{gan2015exact, low2014convex}. Tighter relaxations include SDP~\cite{molzahn2013sufficient} and QC~\cite{coffrin2015qc}.

\subsection{Interior-Point Methods}

IPOPT~\cite{wachter2006implementation} implements a primal-dual interior-point algorithm with filter line search. For power systems, key references include~\cite{capitanescu2011interior, torres2002interior}.

% ============================================================================
\section{Conclusion}
% ============================================================================

GAT demonstrates that a single-binary, Rust-based OPF toolkit can achieve industrial-grade accuracy on standard benchmarks. Key contributions include:

\begin{enumerate}
    \item \textbf{Validated AC-OPF}: $<0.01\%$ objective gap on IEEE 14-bus and 118-bus
    \item \textbf{Complete solver hierarchy}: Economic dispatch $\to$ DC $\to$ SOCP $\to$ AC
    \item \textbf{Analytical derivatives}: Full Jacobian and Hessian for IPOPT
    \item \textbf{Reproducibility}: Open-source implementation with detailed documentation
\end{enumerate}

\subsection{Future Work}

\begin{itemize}
    \item Security-constrained OPF (SCOPF) with N-1 contingencies
    \item Multi-period dispatch with storage and ramp constraints
    \item Distributed OPF decomposition for large networks
    \item GPU acceleration for linear algebra
    \item Learning-augmented warm-start from neural networks
\end{itemize}

GAT is available at \url{https://github.com/monistowl/gat}.

% ============================================================================
\section*{Acknowledgments}
% ============================================================================

We thank the developers of MATPOWER, PowerModels.jl, PGLib-OPF, IPOPT, and Clarabel for providing the foundational tools and test cases that enable rigorous validation of power system analysis software.

% ============================================================================
\bibliographystyle{plain}
\begin{thebibliography}{20}

\bibitem{carpentier1962contribution}
J.~Carpentier,
\newblock ``Contribution à l'étude du dispatching économique,''
\newblock \emph{Bulletin de la Société Française des Électriciens}, vol.~8, no.~3, pp.~431--447, 1962.

\bibitem{zimmerman2011matpower}
R.~D. Zimmerman, C.~E. Murillo-S{\'a}nchez, and R.~J. Thomas,
\newblock ``{MATPOWER}: Steady-state operations, planning, and analysis tools for power systems research and education,''
\newblock \emph{IEEE Transactions on Power Systems}, vol.~26, no.~1, pp.~12--19, 2011.

\bibitem{coffrin2018powermodels}
C.~Coffrin, R.~Bent, K.~Sundar, Y.~Ng, and M.~Lubin,
\newblock ``{PowerModels.jl}: An open-source framework for exploring power flow formulations,''
\newblock in \emph{2018 Power Systems Computation Conference (PSCC)}, pp.~1--8, IEEE, 2018.

\bibitem{thurner2018pandapower}
L.~Thurner, A.~Scheidler, et~al.,
\newblock ``pandapower---an open-source Python tool for convenient modeling, analysis, and optimization of electric power systems,''
\newblock \emph{IEEE Transactions on Power Systems}, vol.~33, no.~6, pp.~6510--6521, 2018.

\bibitem{brown2018pypsa}
T.~Brown, J.~H{\"o}rsch, and D.~Schlachtberger,
\newblock ``{PyPSA}: Python for power system analysis,''
\newblock \emph{Journal of Open Research Software}, vol.~6, no.~1, 2018.

\bibitem{babaeinejadsarookolaee2019power}
S.~Babaeinejadsarookolaee et~al.,
\newblock ``The power grid library for benchmarking {AC} optimal power flow algorithms,''
\newblock arXiv preprint arXiv:1908.02788, 2019.

\bibitem{wachter2006implementation}
A.~W{\"a}chter and L.~T. Biegler,
\newblock ``On the implementation of an interior-point filter line-search algorithm for large-scale nonlinear programming,''
\newblock \emph{Mathematical Programming}, vol.~106, no.~1, pp.~25--57, 2006.

\bibitem{farivar2013branch}
M.~Farivar and S.~H. Low,
\newblock ``Branch flow model: Relaxations and convexification---Part I,''
\newblock \emph{IEEE Transactions on Power Systems}, vol.~28, no.~3, pp.~2554--2564, 2013.

\bibitem{gan2015exact}
L.~Gan, N.~Li, U.~Topcu, and S.~H. Low,
\newblock ``Exact convex relaxation of optimal power flow in radial networks,''
\newblock \emph{IEEE Transactions on Automatic Control}, vol.~60, no.~1, pp.~72--87, 2015.

\bibitem{low2014convex}
S.~H. Low,
\newblock ``Convex relaxation of optimal power flow---Part I: Formulations and equivalence,''
\newblock \emph{IEEE Transactions on Control of Network Systems}, vol.~1, no.~1, pp.~15--27, 2014.

\bibitem{goulart2024clarabel}
P.~J. Goulart and Y.~Chen,
\newblock ``Clarabel: An interior-point solver for conic programs with quadratic objectives,''
\newblock \emph{Optimization Methods and Software}, 2024.

\bibitem{molzahn2013sufficient}
D.~K. Molzahn, J.~T. Holzer, B.~C. Lesieutre, and C.~L. DeMarco,
\newblock ``Implementation of a large-scale optimal power flow solver based on semidefinite programming,''
\newblock \emph{IEEE Transactions on Power Systems}, vol.~28, no.~4, pp.~3987--3998, 2013.

\bibitem{coffrin2015qc}
C.~Coffrin, H.~L. Hijazi, and P.~Van Hentenryck,
\newblock ``The QC relaxation: A theoretical and computational study on optimal power flow,''
\newblock \emph{IEEE Transactions on Power Systems}, vol.~31, no.~4, pp.~3008--3018, 2015.

\bibitem{capitanescu2011interior}
F.~Capitanescu, J.~M. Ramos, P.~Panciatici, et~al.,
\newblock ``State-of-the-art, challenges, and future trends in security constrained optimal power flow,''
\newblock \emph{Electric Power Systems Research}, vol.~81, no.~8, pp.~1731--1741, 2011.

\bibitem{torres2002interior}
G.~L. Torres and V.~H. Quintana,
\newblock ``An interior-point method for nonlinear optimal power flow using voltage rectangular coordinates,''
\newblock \emph{IEEE Transactions on Power Systems}, vol.~13, no.~4, pp.~1211--1218, 1998.

\bibitem{chen2016gridpack}
Y.~Chen, B.~Palmer, and J.~Daily,
\newblock ``GridPACK: A framework for developing power grid simulations on high-performance computing platforms,''
\newblock \emph{International Journal of High Performance Computing Applications}, vol.~30, no.~2, pp.~223--240, 2016.

\bibitem{dommel1968optimal}
H.~W. Dommel and W.~F. Tinney,
\newblock ``Optimal power flow solutions,''
\newblock \emph{IEEE Transactions on Power Apparatus and Systems}, vol.~87, no.~10, pp.~1866--1876, 1968.

\bibitem{liu1989limited}
D.~C. Liu and J.~Nocedal,
\newblock ``On the limited memory BFGS method for large scale optimization,''
\newblock \emph{Mathematical Programming}, vol.~45, no.~1, pp.~503--528, 1989.

\end{thebibliography}

% ============================================================================
\appendix
\section{Algorithm Pseudocode}
% ============================================================================

\begin{lstlisting}[caption={GAT AC-OPF with IPOPT Algorithm}]
ALGORITHM: GAT AC-OPF with IPOPT
INPUT:  Network data, cost functions, limits
OUTPUT: Optimal dispatch (Pg*, Qg*, V*, theta*)

1. Build Y-bus admittance matrix from network topology
2. Initialize: |V| = 1.0, theta = 0, Pg = Pg_mid, Qg = 0

3. OPTIONAL WARM-START:
   IF SOCP warm-start enabled THEN
     Solve SOCP relaxation
     |V| = sqrt(w), Pg = Pg_SOCP, Qg = Qg_SOCP
   END IF

4. Construct IPOPT problem with:
   - Objective gradient (analytical)
   - Constraint Jacobian (sparse, analytical)
   - Lagrangian Hessian (sparse, analytical)

5. Configure IPOPT: mu_init = 1e-4, tol = 1e-6

6. Solve NLP via interior-point method

7. IF IPOPT returns success THEN
     Extract (Pg*, Qg*, V*, theta*)
     Compute LMPs from dual variables
     RETURN OpfSolution
   ELSE
     RETURN Error (infeasible or diverged)
   END IF
\end{lstlisting}

% ============================================================================
\section{Jacobian Sparsity Pattern}
% ============================================================================

The constraint Jacobian has a characteristic sparse structure reflecting the network topology. For a power balance constraint at bus $i$:

\begin{equation}
\nabla g_i = \begin{bmatrix}
\frac{\partial g_i}{\partial |V_1|} & \cdots & \frac{\partial g_i}{\partial |V_n|} &
\frac{\partial g_i}{\partial \theta_1} & \cdots & \frac{\partial g_i}{\partial \theta_n} &
\frac{\partial g_i}{\partial P_{g_1}} & \cdots
\end{bmatrix}
\end{equation}

Non-zeros appear only for:
\begin{itemize}
    \item $\partial g_i / \partial |V_j|$ where $j = i$ or $(i,j) \in \mathcal{E}$
    \item $\partial g_i / \partial \theta_j$ where $j = i$ or $(i,j) \in \mathcal{E}$
    \item $\partial g_i / \partial P_g$ where $g \in \mathcal{G}_i$
    \item $\partial g_i / \partial Q_g$ where $g \in \mathcal{G}_i$
\end{itemize}

Total non-zeros: $O(|\mathcal{N}| \cdot d_{\text{avg}} + |\mathcal{G}|)$ where $d_{\text{avg}}$ is the average node degree.

\end{document}
