\documentclass[11pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{xcolor}
\usepackage[margin=1in]{geometry}
\usepackage{tikz}
\usepackage{multirow}
\usepackage{longtable}
\usepackage{float}
\usetikzlibrary{shapes,arrows,positioning,fit,calc,matrix}

\definecolor{codegray}{rgb}{0.95,0.95,0.95}
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{rustcolor}{rgb}{0.8,0.4,0.0}

\lstset{
  backgroundcolor=\color{codegray},
  basicstyle=\ttfamily\small,
  breaklines=true,
  frame=single,
  keywordstyle=\color{blue},
  commentstyle=\color{codegreen},
  stringstyle=\color{codepurple}
}

\lstdefinelanguage{Rust}{
  keywords={fn, let, mut, pub, struct, enum, impl, use, mod, self, Self, trait, where, async, await, match, if, else, for, while, loop, return, break, continue, const, static, type, unsafe, extern, crate, super, dyn, ref, move, as, in},
  keywordstyle=\color{rustcolor}\bfseries,
  ndkeywords={Vec, Option, Result, String, HashMap, Some, None, Ok, Err, f64, usize, bool},
  ndkeywordstyle=\color{blue},
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{codegreen},
  stringstyle=\color{codepurple},
  morestring=[b]",
}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{definition}{Definition}
\newtheorem{remark}{Remark}

\title{GAT: A High-Performance Rust Toolkit for Power System Analysis}

\author{
  Tom Wilson\\
  \texttt{https://github.com/monistowl/gat}
}

\date{November 2024}

\begin{document}

\maketitle

\begin{abstract}
We present the Grid Analysis Toolkit (GAT), an open-source command-line toolkit for power system analysis implemented in Rust. This comprehensive technical reference documents GAT's complete solver hierarchy for optimal power flow (OPF)---from sub-millisecond economic dispatch through DC-OPF, SOCP relaxation, and full nonlinear AC-OPF with IPOPT---alongside state estimation, N-k contingency analysis, and time-series dispatch. We detail the framework's design decisions rooted in Rust's type system and memory safety guarantees, the challenges of parsing heterogeneous power system datasets (MATPOWER, PSS/E, CIM, pandapower), and the mathematical foundations underlying each analysis module. Extensive benchmarks against PGLib-OPF demonstrate convergence to reference objective values within 0.01\% for standard IEEE test cases. We provide complete mathematical formulations, algorithmic pseudocode, implementation insights, and numerical considerations for reproducibility.
\end{abstract}

\tableofcontents
\newpage

% ============================================================================
\part{Framework Architecture}
% ============================================================================

% ============================================================================
\section{Introduction}
% ============================================================================

The Optimal Power Flow (OPF) problem is fundamental to power system operations, determining the economically optimal generator dispatch subject to physical network constraints. First formulated by Carpentier in 1962~\cite{carpentier1962contribution}, OPF remains computationally challenging due to the non-convex nature of AC power flow equations. Modern grid operations require not only OPF solutions but also state estimation from SCADA measurements, contingency analysis for reliability assessment, and time-series analysis for renewable integration studies.

\subsection{Motivation and Design Goals}

Existing power system analysis tools present significant barriers to adoption:

\begin{enumerate}
    \item \textbf{Proprietary licensing}: Commercial tools (PowerWorld, PSS/E, PSCAD) require expensive licenses
    \item \textbf{Runtime dependencies}: MATPOWER requires MATLAB; PowerModels.jl requires Julia's package ecosystem
    \item \textbf{Installation complexity}: IPOPT, HSL solvers, and SuiteSparse require careful configuration
    \item \textbf{Language fragmentation}: Python (pandapower, PyPSA), Julia (PowerModels), MATLAB (MATPOWER) create interoperability challenges
    \item \textbf{Performance limitations}: Interpreted languages incur overhead; GC pauses affect real-time applications
\end{enumerate}

GAT addresses these limitations through five design principles:

\begin{description}
    \item[Single-binary deployment] Self-contained executable with no runtime dependencies beyond libc
    \item[Memory safety without GC] Rust's ownership system prevents buffer overflows, use-after-free, and data races at compile time
    \item[Type-driven correctness] Newtype wrappers distinguish bus IDs from generator IDs; units are encoded in types
    \item[Composable data pipelines] Apache Arrow/Parquet output integrates with Python, R, DuckDB, and Spark
    \item[Modular solver backends] LP (HiGHS, CBC), conic (Clarabel), and NLP (IPOPT, L-BFGS) solvers are interchangeable
\end{description}

\subsection{Contributions}

This paper makes the following contributions:

\begin{enumerate}
    \item A comprehensive open-source power system analysis toolkit in Rust covering OPF, state estimation, and contingency analysis
    \item Type-safe data modeling using Rust's algebraic data types and newtype patterns
    \item Analytical Jacobian and Hessian derivations for IPOPT-backed AC-OPF with full thermal constraints
    \item Dataset interoperability layer handling MATPOWER, PSS/E RAW, CIM XML, and pandapower JSON formats
    \item PTDF/LODF-based fast contingency screening for N-k analysis
    \item Validation against PGLib-OPF, OPFData, and PF$\Delta$ benchmark suites
    \item Detailed numerical considerations for floating-point stability in power system computations
\end{enumerate}

% ============================================================================
\section{Framework Design Decisions}
% ============================================================================

\subsection{Why Rust?}

The choice of Rust as the implementation language reflects several technical requirements:

\subsubsection{Memory Safety Without Garbage Collection}

Power system analysis involves large sparse matrices (Y-bus for 10,000+ bus systems) and iterative solvers that allocate/deallocate working memory. Garbage collection pauses are unacceptable in:
\begin{itemize}
    \item Real-time contingency screening (sub-second response required)
    \item Monte Carlo reliability studies (millions of iterations)
    \item Time-series analysis with streaming data
\end{itemize}

Rust's ownership system provides memory safety guarantees at compile time without runtime overhead:

\begin{lstlisting}[language=Rust,caption={Ownership prevents use-after-free}]
fn build_ybus(network: &Network) -> SparseMatrix {
    let mut ybus = SparseMatrix::new(network.num_buses());
    for branch in network.branches() {
        // branch is borrowed, cannot be moved/freed
        ybus.add_branch_admittance(branch);
    }
    ybus // Ownership transferred to caller
}
\end{lstlisting}

\subsubsection{Zero-Cost Abstractions}

Rust's abstractions (iterators, traits, generics) compile to the same machine code as hand-written loops:

\begin{lstlisting}[language=Rust,caption={Iterator fusion eliminates intermediate allocations}]
// This compiles to a single loop with no heap allocations
let total_gen: Megawatts = network.generators()
    .filter(|g| g.status)
    .map(|g| g.pmax)
    .sum();
\end{lstlisting}

\subsubsection{Fearless Concurrency}

Rust's type system prevents data races at compile time. The \texttt{Send} and \texttt{Sync} traits encode thread-safety:

\begin{lstlisting}[language=Rust,caption={Parallel contingency analysis with rayon}]
use rayon::prelude::*;

let violations: Vec<_> = contingencies
    .par_iter()  // Parallel iteration
    .filter_map(|c| {
        let post_flow = lodf.estimate_post_outage(&base_flow, c);
        check_violations(&post_flow, &limits)
    })
    .collect();
\end{lstlisting}

\subsubsection{Foreign Function Interface (FFI)}

Rust has zero-overhead interop with C libraries, essential for leveraging:
\begin{itemize}
    \item IPOPT (C++ with C interface) for nonlinear optimization
    \item SuiteSparse (CHOLMOD, UMFPACK) for sparse linear algebra
    \item BLAS/LAPACK for dense operations
\end{itemize}

\subsection{Crate Architecture}

GAT is organized as a Rust workspace with modular crates following the principle of separation of concerns:

\begin{figure}[H]
\centering
\resizebox{0.9\textwidth}{!}{%
\begin{tikzpicture}[
    crate/.style={rectangle, draw, rounded corners, minimum width=2.2cm, minimum height=0.8cm, align=center, font=\small\ttfamily},
    dep/.style={->, >=stealth, thick}
]
    % Core layer
    \node[crate, fill=blue!20] (core) at (0,0) {gat-core};

    % IO layer
    \node[crate, fill=green!20] (io) at (-2.5,-1.5) {gat-io};

    % Algorithm layer
    \node[crate, fill=orange!20] (algo) at (0,-1.5) {gat-algo};

    % Solver backends
    \node[crate, fill=yellow!20] (ipopt) at (-3.5,-3) {gat-ipopt};
    \node[crate, fill=yellow!20] (cbc) at (-1.5,-3) {gat-cbc};
    \node[crate, fill=yellow!20] (clp) at (0.5,-3) {gat-clp};

    % Application layer
    \node[crate, fill=red!20] (cli) at (2.5,-1.5) {gat-cli};
    \node[crate, fill=red!20] (tui) at (4.5,-1.5) {gat-tui};

    % Specialized
    \node[crate, fill=purple!20] (ts) at (2.5,-3) {gat-ts};
    \node[crate, fill=purple!20] (dist) at (4.5,-3) {gat-dist};

    % Dependencies
    \draw[dep] (io) -- (core);
    \draw[dep] (algo) -- (core);
    \draw[dep] (cli) -- (algo);
    \draw[dep] (cli) -- (io);
    \draw[dep] (tui) -- (algo);
    \draw[dep] (ipopt) -- (algo);
    \draw[dep] (cbc) -- (algo);
    \draw[dep] (clp) -- (algo);
    \draw[dep] (ts) -- (algo);
    \draw[dep] (dist) -- (algo);
\end{tikzpicture}%
}
\caption{GAT crate dependency graph. Core types flow upward; solver backends are optional features.}
\label{fig:crate_arch}
\end{figure}

\begin{table}[H]
\centering
\caption{GAT Crate Responsibilities}
\begin{tabular}{llp{7cm}}
\toprule
Crate & LOC & Responsibility \\
\midrule
\texttt{gat-core} & $\sim$900 & Network graph model, element types (Bus, Gen, Load, Branch), ID newtypes, validation \\
\texttt{gat-io} & $\sim$3,500 & Importers (MATPOWER, PSS/E, CIM, pandapower), Arrow schema, exporters \\
\texttt{gat-algo} & $\sim$8,000 & OPF solvers, power flow, state estimation, contingency, PTDF/LODF \\
\texttt{gat-ipopt} & $\sim$500 & IPOPT FFI bindings, NLP problem wrapper \\
\texttt{gat-cbc} & $\sim$300 & CBC MILP solver bindings \\
\texttt{gat-clp} & $\sim$300 & CLP LP solver bindings \\
\texttt{gat-cli} & $\sim$2,000 & Command-line interface, subcommands, output formatting \\
\texttt{gat-tui} & $\sim$1,500 & Terminal UI dashboard (ratatui-based) \\
\texttt{gat-ts} & $\sim$1,200 & Time-series dispatch, multi-period OPF \\
\texttt{gat-dist} & $\sim$800 & Distribution system analysis, radial power flow \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Type-Driven Design}

\subsubsection{Newtype Pattern for IDs}

Power system models reference elements by ID. Confusing a bus ID with a generator ID causes silent bugs. GAT uses Rust's newtype pattern:

\begin{lstlisting}[language=Rust,caption={Newtype wrappers prevent ID confusion}]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct BusId(usize);

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct GenId(usize);

// Compile error: expected BusId, found GenId
fn get_bus_voltage(network: &Network, id: BusId) -> f64 { ... }
let gen_id = GenId::new(1);
get_bus_voltage(&network, gen_id);  // ERROR!
\end{lstlisting}

\subsubsection{Algebraic Data Types for Network Elements}

The network graph uses enums to represent heterogeneous node types:

\begin{lstlisting}[language=Rust,caption={Sum types for network elements}]
pub enum Node {
    Bus(Bus),
    Gen(Gen),
    Load(Load),
    Shunt(Shunt),
}

pub enum Edge {
    Branch(Branch),
    Transformer(Transformer),
}

// Pattern matching ensures exhaustive handling
match node {
    Node::Bus(b) => process_bus(b),
    Node::Gen(g) => process_gen(g),
    Node::Load(l) => process_load(l),
    Node::Shunt(s) => process_shunt(s),
}
\end{lstlisting}

\subsubsection{Builder Pattern for Complex Objects}

Generator objects have many optional fields. The builder pattern provides ergonomic construction:

\begin{lstlisting}[language=Rust,caption={Builder pattern for generators}]
let gen = Gen::new(GenId::new(1), "Gen1".into(), BusId::new(1))
    .with_p_limits(10.0, 100.0)
    .with_q_limits(-50.0, 50.0)
    .with_cost(CostModel::quadratic(0.0, 20.0, 0.01))
    .as_synchronous_condenser();
\end{lstlisting}

\subsection{Graph-Based Network Model}

GAT models power networks as undirected multigraphs using \texttt{petgraph}:

\begin{definition}[Network Graph]
A power network is a tuple $G = (V, E)$ where:
\begin{itemize}
    \item $V = V_B \cup V_G \cup V_L \cup V_S$ (buses, generators, loads, shunts)
    \item $E = E_{BR} \cup E_{TX}$ (branches, transformers)
    \item Parallel edges allowed (multiple circuits between buses)
\end{itemize}
\end{definition}

This representation enables:
\begin{itemize}
    \item $O(1)$ neighbor lookup for Y-bus construction
    \item Efficient island detection via connected components
    \item Natural representation of multi-terminal devices
    \item Incremental updates for contingency analysis
\end{itemize}

\subsection{Data Pipeline: Arrow and Parquet}

GAT uses Apache Arrow for in-memory columnar data and Parquet for persistent storage:

\begin{figure}[H]
\centering
\begin{tikzpicture}[
    node distance=1cm,
    box/.style={rectangle, draw, rounded corners, minimum width=2cm, minimum height=0.7cm, align=center, font=\small},
    arrow/.style={->, >=stealth, thick}
]
    \node[box] (import) {MATPOWER\\PSS/E\\CIM};
    \node[box, right=of import] (arrow) {Arrow\\Tables};
    \node[box, right=of arrow] (algo) {Solver\\Algorithms};
    \node[box, right=of algo] (out) {Parquet\\Output};
    \node[box, below=0.8cm of out] (python) {Python\\Polars};
    \node[box, left=of python] (duckdb) {DuckDB\\SQL};

    \draw[arrow] (import) -- (arrow);
    \draw[arrow] (arrow) -- (algo);
    \draw[arrow] (algo) -- (out);
    \draw[arrow] (out) -- (python);
    \draw[arrow] (out) -- (duckdb);
\end{tikzpicture}
\caption{Data pipeline: heterogeneous inputs to columnar outputs}
\end{figure}

Benefits of this approach:
\begin{itemize}
    \item Zero-copy reads: Memory-mapped Parquet files avoid deserialization
    \item Schema evolution: New columns can be added without breaking consumers
    \item Compression: Parquet typically achieves 5-10$\times$ compression
    \item Interoperability: Python (Polars, Pandas), R (arrow), Spark, DuckDB
\end{itemize}

% ============================================================================
\section{Dataset Challenges and Validation}
% ============================================================================

Power system data comes in diverse formats with inconsistent conventions. GAT's IO layer handles these challenges through format-specific parsers and a unified validation framework.

\subsection{Format Heterogeneity}

\begin{table}[H]
\centering
\caption{Supported Input Formats and Their Challenges}
\begin{tabular}{lp{4cm}p{6cm}}
\toprule
Format & Origin & Key Challenges \\
\midrule
MATPOWER & Academia (MATLAB) & Inconsistent bus numbering (1-based vs 0-based), optional gencost, version variations \\
PSS/E RAW & Industry (Siemens) & Fixed-width fields, multiple revisions (23-35), zone/area encoding \\
CIM XML & IEC 61970 & Deep inheritance hierarchy, multiple profiles (CGMES, CIM14), UUIDs \\
pandapower & Python ecosystem & Python-specific serialization, NumPy dtype variations \\
\bottomrule
\end{tabular}
\end{table}

\subsection{MATPOWER Parsing Challenges}

MATPOWER files are MATLAB scripts defining matrices. Key parsing challenges include:

\subsubsection{Matrix Section Detection}

\begin{lstlisting}[language=Rust,caption={MATPOWER matrix section parsing}]
// Must check "mpc.gencost" before "mpc.gen" (prefix collision)
if trimmed.starts_with("mpc.gencost") && trimmed.contains('[') {
    case.gencost = parse_gencost_section(trimmed, &mut lines)?;
} else if trimmed.starts_with("mpc.gen") && trimmed.contains('[') {
    case.gen = parse_gen_section(trimmed, &mut lines)?;
}
\end{lstlisting}

\subsubsection{Bus Numbering}

MATPOWER uses 1-based bus numbers that may be non-contiguous:
\begin{itemize}
    \item IEEE cases: Bus 1, 2, 3, ..., n
    \item Real cases: Bus 101, 205, 1042, ... (arbitrary IDs)
\end{itemize}

GAT maintains a bidirectional mapping between external IDs and internal indices.

\subsubsection{Cost Function Formats}

MATPOWER supports polynomial and piecewise-linear costs with variable coefficient counts:

\begin{lstlisting}[caption={MATPOWER gencost variations}]
% Polynomial (model=2): ncost coefficients, highest degree first
% cost = c_n*P^n + ... + c_1*P + c_0
mpc.gencost = [
    2 0 0 3   0.02  15.0  0.0;   % Quadratic: 0.02*P^2 + 15*P
    2 0 0 2   25.0  0.0;          % Linear: 25*P
];

% Piecewise linear (model=1): ncost (MW, $/hr) pairs
mpc.gencost = [
    1 0 0 4   0 0   50 1000   100 2500   150 5000;
];
\end{lstlisting}

\subsection{PSS/E RAW Format}

PSS/E RAW files use fixed-width records with revision-specific layouts:

\begin{lstlisting}[caption={PSS/E revision handling}]
IC,    SESSION,    NREC,   NREC_GEN,   ... (Case ID record)
0,      14.1,      '  ', 100.0    / PSS(R)E-33.4 (Rev 33 format)

 101,'BUS1    ',  138.0,1,   1,   1,   1,1.0450,   0.0,...
 205,'BUS2    ',  138.0,1,   1,   1,   1,1.0320,  -5.2,...
\end{lstlisting}

Challenges:
\begin{itemize}
    \item Field widths vary by revision (Rev 23 vs Rev 33)
    \item Quote handling for names varies
    \item Continuation records for long lines
    \item Zone and area encoding differences
\end{itemize}

\subsection{CIM/CGMES XML}

Common Information Model (CIM) uses XML with deep inheritance:

\begin{lstlisting}[language=XML,caption={CIM inheritance example}]
<cim:SynchronousMachine rdf:ID="_gen1">
  <cim:IdentifiedObject.name>Gen1</cim:IdentifiedObject.name>
  <cim:RotatingMachine.ratedS>100</cim:RotatingMachine.ratedS>
  <cim:SynchronousMachine.type>generator</cim:SynchronousMachine.type>
  <cim:Equipment.EquipmentContainer rdf:resource="#_substation1"/>
</cim:SynchronousMachine>
\end{lstlisting}

GAT's CIM parser must:
\begin{itemize}
    \item Resolve RDF references across files
    \item Handle multiple CIM profiles (Equipment, Topology, StateVariables)
    \item Map CIM's equipment-centric model to bus-branch
\end{itemize}

\subsection{Unified Validation Framework}

All importers feed into a common validation layer:

\begin{lstlisting}[language=Rust,caption={Validation diagnostics}]
pub struct Diagnostics {
    pub issues: Vec<DiagnosticIssue>,
}

pub enum Severity { Warning, Error }

pub struct DiagnosticIssue {
    pub severity: Severity,
    pub category: String,  // "structure", "capacity", "impedance"
    pub message: String,
}

// Validation checks
network.validate_into(&mut diag);
// - No buses: Error
// - Zero total load: Error (likely parser bug)
// - Gen capacity < load: Warning
// - Disconnected buses: Warning
// - Zero-impedance branches: Warning
\end{lstlisting}

\subsection{Per-Unit Normalization}

Power systems use per-unit (p.u.) normalization to simplify calculations:

\begin{align}
Z_{\text{p.u.}} &= \frac{Z_{\Omega}}{Z_{\text{base}}} = \frac{Z_{\Omega} \cdot S_{\text{base}}}{V_{\text{base}}^2} \\
S_{\text{p.u.}} &= \frac{S_{\text{MVA}}}{S_{\text{base}}}
\end{align}

Common issues:
\begin{itemize}
    \item MATPOWER uses system base (100 MVA) while PSS/E may use machine bases
    \item Transformer impedances may be on transformer MVA base vs system base
    \item Line charging susceptance units vary ($\mu$S, p.u., MVAR)
\end{itemize}

GAT normalizes all quantities to system p.u. during import.

% ============================================================================
\part{Mathematical Foundations}
% ============================================================================

% ============================================================================
\section{AC Power Flow Equations}
% ============================================================================

\subsection{Notation}

\begin{table}[H]
\centering
\caption{Mathematical Notation}
\begin{tabular}{ll}
\toprule
Symbol & Description \\
\midrule
$\mathcal{N}$ & Set of buses (nodes), indexed by $i$ \\
$\mathcal{E}$ & Set of branches (edges), indexed by $(i,j)$ \\
$\mathcal{G}_i$ & Set of generators at bus $i$ \\
$V_i = |V_i|e^{j\theta_i}$ & Complex voltage at bus $i$ \\
$P_i, Q_i$ & Real and reactive power injection at bus $i$ \\
$P_g, Q_g$ & Generator real and reactive power output \\
$P_{ij}, Q_{ij}$ & Real and reactive power flow on branch $(i,j)$ \\
$Y_{ij} = G_{ij} + jB_{ij}$ & Element $(i,j)$ of Y-bus admittance matrix \\
$S_{\text{base}}$ & System base power (typically 100 MVA) \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Bus Injection Equations}

From Kirchhoff's current law, the complex power injection at bus $i$ is:
\begin{equation}
S_i = V_i I_i^* = V_i \sum_{j \in \mathcal{N}} Y_{ij}^* V_j^*
\end{equation}

Expanding in polar coordinates ($V_k = |V_k|e^{j\theta_k}$):
\begin{align}
P_i &= \sum_{j \in \mathcal{N}} |V_i||V_j|\left[G_{ij}\cos(\theta_i - \theta_j) + B_{ij}\sin(\theta_i - \theta_j)\right] \label{eq:p_inj} \\
Q_i &= \sum_{j \in \mathcal{N}} |V_i||V_j|\left[G_{ij}\sin(\theta_i - \theta_j) - B_{ij}\cos(\theta_i - \theta_j)\right] \label{eq:q_inj}
\end{align}

\subsection{Y-Bus Admittance Matrix}

The Y-bus matrix $\mathbf{Y} \in \mathbb{C}^{n \times n}$ encodes network topology. For a branch from $i$ to $j$ with series admittance $y_s = 1/(r + jx)$, shunt susceptance $b_c$, and complex tap ratio $a = t e^{j\phi}$:

\begin{figure}[H]
\centering
\begin{tikzpicture}[scale=1.2]
    % Bus i
    \draw[thick] (0,0) -- (0,1);
    \node[below] at (0,0) {Bus $i$};
    \fill (0,0.5) circle (2pt);

    % Ideal transformer
    \draw (0,0.5) -- (1,0.5);
    \draw (1,0.2) -- (1,0.8);
    \draw (1.3,0.2) -- (1.3,0.8);
    \node[above] at (1.15,0.8) {\small $a:1$};

    % Series impedance
    \draw (1.3,0.5) -- (2,0.5);
    \draw[thick] (2,0.3) rectangle (3.5,0.7);
    \node at (2.75,0.5) {$y_s$};

    % Shunt admittances
    \draw (1.3,0.5) -- (1.3,-0.3);
    \draw (1.1,-0.3) -- (1.5,-0.3);
    \draw (1.15,-0.3) -- (1.15,-0.5);
    \draw (1.45,-0.3) -- (1.45,-0.5);
    \node[below] at (1.3,-0.5) {\small $jb_c/2$};

    \draw (3.5,0.5) -- (3.5,-0.3);
    \draw (3.3,-0.3) -- (3.7,-0.3);
    \draw (3.35,-0.3) -- (3.35,-0.5);
    \draw (3.65,-0.3) -- (3.65,-0.5);
    \node[below] at (3.5,-0.5) {\small $jb_c/2$};

    % Bus j
    \draw (3.5,0.5) -- (4.5,0.5);
    \draw[thick] (4.5,0) -- (4.5,1);
    \node[below] at (4.5,0) {Bus $j$};
    \fill (4.5,0.5) circle (2pt);
\end{tikzpicture}
\caption{$\Pi$-equivalent branch model with off-nominal tap}
\end{figure}

The Y-bus contributions from this branch are:

\begin{align}
Y_{ii} &\mathrel{+}= \frac{y_s + jb_c/2}{|a|^2} \\
Y_{jj} &\mathrel{+}= y_s + jb_c/2 \\
Y_{ij} &\mathrel{+}= -\frac{y_s}{a^*} \\
Y_{ji} &\mathrel{+}= -\frac{y_s}{a}
\end{align}

For a transmission line ($a = 1$), this simplifies to:
\begin{align}
Y_{ii} &\mathrel{+}= y_s + jb_c/2 \\
Y_{jj} &\mathrel{+}= y_s + jb_c/2 \\
Y_{ij} = Y_{ji} &\mathrel{+}= -y_s
\end{align}

\subsection{Branch Flow Equations}

For a branch from bus $i$ (from side) to bus $j$ (to side):

\textbf{From-side power flow:}
\begin{align}
P_{ij}^{\text{f}} &= \frac{|V_i|^2}{|a|^2} g_s - \frac{|V_i||V_j|}{|a|} \left[g_s\cos(\theta_{ij} - \phi) + b_s\sin(\theta_{ij} - \phi)\right] \\
Q_{ij}^{\text{f}} &= -\frac{|V_i|^2}{|a|^2}(b_s + b_c/2) - \frac{|V_i||V_j|}{|a|} \left[g_s\sin(\theta_{ij} - \phi) - b_s\cos(\theta_{ij} - \phi)\right]
\end{align}

\textbf{To-side power flow:}
\begin{align}
P_{ij}^{\text{t}} &= |V_j|^2 g_s - \frac{|V_i||V_j|}{|a|} \left[g_s\cos(\theta_{ji} + \phi) + b_s\sin(\theta_{ji} + \phi)\right] \\
Q_{ij}^{\text{t}} &= -|V_j|^2(b_s + b_c/2) - \frac{|V_i||V_j|}{|a|} \left[g_s\sin(\theta_{ji} + \phi) - b_s\cos(\theta_{ji} + \phi)\right]
\end{align}

where $g_s + jb_s = y_s$ and $\theta_{ij} = \theta_i - \theta_j$.

\subsection{Newton-Raphson Power Flow}

The AC power flow problem solves for voltage magnitudes and angles given specified injections. For PQ buses (fixed $P$, $Q$) and PV buses (fixed $P$, $|V|$):

\begin{equation}
\mathbf{f}(\mathbf{x}) = \begin{bmatrix}
P_i^{\text{spec}} - P_i^{\text{calc}}(\mathbf{V}, \boldsymbol{\theta}) \\
Q_i^{\text{spec}} - Q_i^{\text{calc}}(\mathbf{V}, \boldsymbol{\theta})
\end{bmatrix} = \mathbf{0}
\end{equation}

Newton-Raphson iterates:
\begin{equation}
\mathbf{x}^{(k+1)} = \mathbf{x}^{(k)} - \mathbf{J}^{-1} \mathbf{f}(\mathbf{x}^{(k)})
\end{equation}

where the Jacobian has the structure:
\begin{equation}
\mathbf{J} = \begin{bmatrix}
\dfrac{\partial \mathbf{P}}{\partial \boldsymbol{\theta}} & \dfrac{\partial \mathbf{P}}{\partial \mathbf{V}} \\[1em]
\dfrac{\partial \mathbf{Q}}{\partial \boldsymbol{\theta}} & \dfrac{\partial \mathbf{Q}}{\partial \mathbf{V}}
\end{bmatrix}
\end{equation}

\subsubsection{Jacobian Elements}

For bus $i$, the Jacobian elements are:

\textbf{Diagonal elements:}
\begin{align}
\frac{\partial P_i}{\partial \theta_i} &= -Q_i - B_{ii}|V_i|^2 \\
\frac{\partial P_i}{\partial |V_i|} &= \frac{P_i}{|V_i|} + G_{ii}|V_i| \\
\frac{\partial Q_i}{\partial \theta_i} &= P_i - G_{ii}|V_i|^2 \\
\frac{\partial Q_i}{\partial |V_i|} &= \frac{Q_i}{|V_i|} - B_{ii}|V_i|
\end{align}

\textbf{Off-diagonal elements} (for $j \neq i$):
\begin{align}
\frac{\partial P_i}{\partial \theta_j} &= |V_i||V_j|(G_{ij}\sin\theta_{ij} - B_{ij}\cos\theta_{ij}) \\
\frac{\partial P_i}{\partial |V_j|} &= |V_i|(G_{ij}\cos\theta_{ij} + B_{ij}\sin\theta_{ij}) \\
\frac{\partial Q_i}{\partial \theta_j} &= -|V_i||V_j|(G_{ij}\cos\theta_{ij} + B_{ij}\sin\theta_{ij}) \\
\frac{\partial Q_i}{\partial |V_j|} &= |V_i|(G_{ij}\sin\theta_{ij} - B_{ij}\cos\theta_{ij})
\end{align}

\subsubsection{Convergence Criteria}

GAT uses the following convergence criteria:
\begin{itemize}
    \item Maximum mismatch: $\|\mathbf{f}\|_\infty < \epsilon_{\text{tol}}$ (default $10^{-6}$ p.u.)
    \item Maximum iterations: 50 (rarely needed for well-conditioned systems)
    \item Step damping for ill-conditioned systems
\end{itemize}

% ============================================================================
\section{Optimal Power Flow Formulation}
% ============================================================================

\subsection{General AC-OPF}

The AC-OPF minimizes generation cost subject to physical and operational constraints:

\begin{equation}
\boxed{
\begin{aligned}
\min_{\mathbf{V}, \boldsymbol{\theta}, \mathbf{P}_g, \mathbf{Q}_g} \quad & \sum_{g \in \mathcal{G}} C_g(P_g) \\
\text{s.t.} \quad & P_i^{\text{gen}} - P_i^{\text{load}} = P_i^{\text{calc}}(\mathbf{V}, \boldsymbol{\theta}) & \forall i \in \mathcal{N} \\
& Q_i^{\text{gen}} - Q_i^{\text{load}} = Q_i^{\text{calc}}(\mathbf{V}, \boldsymbol{\theta}) & \forall i \in \mathcal{N} \\
& V_i^{\min} \leq |V_i| \leq V_i^{\max} & \forall i \in \mathcal{N} \\
& P_g^{\min} \leq P_g \leq P_g^{\max} & \forall g \in \mathcal{G} \\
& Q_g^{\min} \leq Q_g \leq Q_g^{\max} & \forall g \in \mathcal{G} \\
& |S_{ij}| \leq S_{ij}^{\max} & \forall (i,j) \in \mathcal{E} \\
& \theta_{\text{ref}} = 0 & \text{(angle reference)}
\end{aligned}
}
\label{eq:acopf_full}
\end{equation}

\subsection{Cost Functions}

GAT supports three cost function types:

\begin{enumerate}
    \item \textbf{Polynomial:} $C(P) = \sum_{k=0}^{n} c_k P^k$ (typically quadratic: $c_0 + c_1 P + c_2 P^2$)
    \item \textbf{Piecewise linear:} Linear interpolation between $(P_k, C_k)$ breakpoints
    \item \textbf{No cost:} $C(P) = 0$ (for must-run units)
\end{enumerate}

The quadratic cost objective yields a convex function in $P_g$, but the AC power flow constraints make the overall problem non-convex.

\subsection{Locational Marginal Prices (LMPs)}

The LMP at bus $i$ is the marginal cost of serving an additional MW of load:

\begin{equation}
\text{LMP}_i = \frac{\partial \mathcal{L}}{\partial P_i^{\text{load}}} = \lambda_i^P
\end{equation}

where $\lambda_i^P$ is the dual variable (Lagrange multiplier) for the real power balance constraint at bus $i$.

LMPs decompose into three components:
\begin{equation}
\text{LMP}_i = \lambda_{\text{ref}} + \text{Loss}_i + \text{Congestion}_i
\end{equation}

where:
\begin{itemize}
    \item $\lambda_{\text{ref}}$: System energy price (at reference bus)
    \item Loss$_i$: Marginal loss component (sensitivity of losses to injection at $i$)
    \item Congestion$_i$: Shadow prices of binding transmission constraints
\end{itemize}

% ============================================================================
\section{Solver Hierarchy}
% ============================================================================

GAT provides four OPF methods with increasing fidelity and computational cost:

\begin{figure}[H]
\centering
\resizebox{\textwidth}{!}{%
\begin{tikzpicture}[
    node distance=1.5cm,
    box/.style={rectangle, draw, rounded corners, minimum width=3cm, minimum height=1.2cm, align=center},
    arrow/.style={->, >=stealth, thick}
]
    \node[box, fill=green!20] (ed) {Economic Dispatch\\Merit Order\\$O(n \log n)$};
    \node[box, fill=blue!20, right=of ed] (dc) {DC-OPF\\Linear Program\\$O(n^{2.5})$};
    \node[box, fill=orange!20, right=of dc] (socp) {SOCP Relaxation\\Conic Program\\$O(n^3)$};
    \node[box, fill=red!20, right=of socp] (ac) {AC-OPF\\Nonlinear NLP\\$O(k \cdot n^3)$};

    \draw[arrow] (ed) -- (dc) node[midway,above] {\small +network};
    \draw[arrow] (dc) -- (socp) node[midway,above] {\small +voltages};
    \draw[arrow] (socp) -- (ac) node[midway,above] {\small +exactness};

    \node[below=0.5cm of ed, font=\small, align=center] {$\sim$20\% gap\\$<$1 ms};
    \node[below=0.5cm of dc, font=\small, align=center] {$\sim$3-5\% gap\\$<$100 ms};
    \node[below=0.5cm of socp, font=\small, align=center] {$\sim$1-3\% gap\\$<$10 s};
    \node[below=0.5cm of ac, font=\small, align=center] {$<$0.01\% gap\\$<$60 s};
\end{tikzpicture}%
}
\caption{Solver hierarchy with typical accuracy and timing (118-bus system)}
\end{figure}

\subsection{Economic Dispatch}

The simplest approach ignores network constraints entirely:

\begin{equation}
\begin{aligned}
\min_{\mathbf{P}_g} \quad & \sum_{g} C_g(P_g) \\
\text{s.t.} \quad & \sum_g P_g = \sum_i P_i^{\text{load}} + P^{\text{loss}} \\
& P_g^{\min} \leq P_g \leq P_g^{\max}
\end{aligned}
\end{equation}

For quadratic costs, the KKT conditions yield the equal incremental cost criterion:
\begin{equation}
\frac{dC_g}{dP_g} = \lambda \quad \text{for all } g \text{ not at limits}
\end{equation}

\subsection{DC Optimal Power Flow}

DC-OPF linearizes under three assumptions:
\begin{enumerate}
    \item Flat voltage profile: $|V_i| \approx 1.0$ p.u.
    \item Small angles: $\sin\theta_{ij} \approx \theta_{ij}$, $\cos\theta_{ij} \approx 1$
    \item Lossless lines: $r_{ij} \ll x_{ij}$
\end{enumerate}

\begin{equation}
\boxed{
\begin{aligned}
\min_{\mathbf{P}_g, \boldsymbol{\theta}} \quad & \sum_g c_{1,g} P_g \\
\text{s.t.} \quad & \sum_{g \in \mathcal{G}_i} P_g - P_i^{\text{load}} = \sum_j B_{ij}(\theta_i - \theta_j) \\
& P_g^{\min} \leq P_g \leq P_g^{\max} \\
& |P_{ij}| \leq P_{ij}^{\max} \\
& \theta_{\text{ref}} = 0
\end{aligned}
}
\end{equation}

This is a linear program solvable by HiGHS or CBC in milliseconds.

\subsection{SOCP Relaxation}

The Second-Order Cone Programming relaxation uses branch-flow variables:

\begin{definition}[Branch-Flow Variables]
\begin{align}
w_i &= |V_i|^2 \quad \text{(squared voltage)} \\
\ell_{ij} &= |I_{ij}|^2 \quad \text{(squared current)} \\
P_{ij}, Q_{ij} &\quad \text{(branch power flows)}
\end{align}
\end{definition}

The exact relationship $P_{ij}^2 + Q_{ij}^2 = w_i \ell_{ij}$ is relaxed to:
\begin{equation}
\left\| \begin{pmatrix} 2P_{ij} \\ 2Q_{ij} \\ w_i - \ell_{ij} \end{pmatrix} \right\|_2 \leq w_i + \ell_{ij}
\end{equation}

\begin{theorem}[Exactness for Radial Networks~\cite{farivar2013branch}]
For radial (tree) networks with convex costs and no upper voltage bounds, the SOCP relaxation is exact at optimum.
\end{theorem}

For meshed networks, the relaxation is typically tight within 1-3\% of AC-OPF.

\subsection{Full Nonlinear AC-OPF}

GAT provides two backends for AC-OPF:

\subsubsection{L-BFGS Penalty Method (Pure Rust)}

A penalty-based approach converts constraints to objective terms:
\begin{equation}
\min_{\mathbf{x}} f(\mathbf{x}) + \rho \sum_i \max(0, h_i(\mathbf{x}))^2 + \mu \sum_j g_j(\mathbf{x})^2
\end{equation}

L-BFGS~\cite{liu1989limited} approximates the Hessian using gradient history, requiring only gradient evaluations.

\subsubsection{IPOPT Interior-Point Method}

IPOPT~\cite{wachter2006implementation} solves the barrier subproblem:
\begin{equation}
\min_{\mathbf{x}} f(\mathbf{x}) - \mu \sum_i \ln(s_i) \quad \text{s.t. } \mathbf{g}(\mathbf{x}) = \mathbf{0}, \; \mathbf{h}(\mathbf{x}) + \mathbf{s} = \mathbf{0}
\end{equation}

GAT provides analytical Jacobian and Hessian for IPOPT, enabling quadratic convergence.

% ============================================================================
\section{Analytical Derivatives for IPOPT}
% ============================================================================

\subsection{Problem Structure}

The IPOPT problem has $n_{\text{var}} = 2n_{\text{bus}} + 2n_{\text{gen}}$ variables:
\begin{equation}
\mathbf{x} = [|V_1|, \ldots, |V_n|, \theta_1, \ldots, \theta_n, P_{g_1}, \ldots, P_{g_m}, Q_{g_1}, \ldots, Q_{g_m}]^T
\end{equation}

Constraints:
\begin{itemize}
    \item $2n_{\text{bus}} + 1$ equality constraints (P balance, Q balance, reference angle)
    \item $2n_{\text{thermal}}$ inequality constraints (from/to thermal limits)
\end{itemize}

\subsection{Jacobian Sparsity Pattern}

The Jacobian has structure determined by the Y-bus sparsity:

\begin{equation}
\mathbf{J} = \begin{bmatrix}
\frac{\partial P}{\partial V} & \frac{\partial P}{\partial \theta} & -\mathbf{I}_g^P & \mathbf{0} \\[0.5em]
\frac{\partial Q}{\partial V} & \frac{\partial Q}{\partial \theta} & \mathbf{0} & -\mathbf{I}_g^Q \\[0.5em]
\mathbf{0} & [0,\ldots,1,\ldots,0] & \mathbf{0} & \mathbf{0} \\[0.5em]
\frac{\partial S^2}{\partial V} & \frac{\partial S^2}{\partial \theta} & \mathbf{0} & \mathbf{0}
\end{bmatrix}
\end{equation}

where $\mathbf{I}_g^P$ and $\mathbf{I}_g^Q$ are sparse matrices mapping generators to their buses.

\subsection{Thermal Constraint Jacobian}

For thermal constraint $h = P^2 + Q^2 - S_{\max}^2 \leq 0$:

\begin{equation}
\frac{\partial h}{\partial x_k} = 2P \frac{\partial P}{\partial x_k} + 2Q \frac{\partial Q}{\partial x_k}
\end{equation}

\textbf{Implementation note:} The to-side thermal constraint requires careful application of the chain rule for $\theta_{\text{diff}} = \theta_j - \theta_i + \phi$:

\begin{align}
\frac{\partial h^{\text{to}}}{\partial \theta_i} &= 2P^{\text{to}} \cdot \left(-\frac{\partial P^{\text{to}}}{\partial \theta_{\text{diff}}}\right) + 2Q^{\text{to}} \cdot \left(-\frac{\partial Q^{\text{to}}}{\partial \theta_{\text{diff}}}\right) \\
\frac{\partial h^{\text{to}}}{\partial \theta_j} &= 2P^{\text{to}} \cdot \left(+\frac{\partial P^{\text{to}}}{\partial \theta_{\text{diff}}}\right) + 2Q^{\text{to}} \cdot \left(+\frac{\partial Q^{\text{to}}}{\partial \theta_{\text{diff}}}\right)
\end{align}

This sign correction reduced Jacobian errors from $72\times$ to machine precision on case118.

\subsection{Hessian of the Lagrangian}

The Hessian $\nabla^2 \mathcal{L}$ includes:
\begin{enumerate}
    \item Objective: $\nabla^2 f = \text{diag}(0, \ldots, 0, 2c_{2,1}, \ldots, 2c_{2,m}, 0, \ldots, 0)$
    \item Power balance: Second derivatives of $P_i$, $Q_i$ w.r.t. $V$, $\theta$
    \item Thermal limits: Second derivatives of $P_{ij}^2 + Q_{ij}^2$
\end{enumerate}

GAT computes the full analytical Hessian with sparsity pattern matching the Y-bus structure.

% ============================================================================
\section{State Estimation}
% ============================================================================

State estimation infers the system state from noisy SCADA measurements.

\subsection{Measurement Model}

Let $\mathbf{x} = [|V|, \theta]^T$ be the state vector. Measurements $\mathbf{z}$ relate to state via:
\begin{equation}
\mathbf{z} = \mathbf{h}(\mathbf{x}) + \boldsymbol{\epsilon}
\end{equation}

where $\boldsymbol{\epsilon} \sim \mathcal{N}(\mathbf{0}, \mathbf{R})$ and $\mathbf{R} = \text{diag}(\sigma_1^2, \ldots, \sigma_m^2)$.

Common measurement types:
\begin{itemize}
    \item Voltage magnitude: $z = |V_i| + \epsilon$
    \item Real power injection: $z = P_i(\mathbf{x}) + \epsilon$
    \item Reactive power injection: $z = Q_i(\mathbf{x}) + \epsilon$
    \item Real power flow: $z = P_{ij}(\mathbf{x}) + \epsilon$
    \item Reactive power flow: $z = Q_{ij}(\mathbf{x}) + \epsilon$
\end{itemize}

\subsection{Weighted Least Squares}

The WLS estimator minimizes:
\begin{equation}
\hat{\mathbf{x}} = \arg\min_{\mathbf{x}} J(\mathbf{x}) = \sum_k \frac{(z_k - h_k(\mathbf{x}))^2}{\sigma_k^2}
\end{equation}

The normal equations are:
\begin{equation}
\mathbf{G} \Delta \mathbf{x} = \mathbf{H}^T \mathbf{R}^{-1} [\mathbf{z} - \mathbf{h}(\mathbf{x})]
\end{equation}

where $\mathbf{G} = \mathbf{H}^T \mathbf{R}^{-1} \mathbf{H}$ is the gain matrix and $\mathbf{H} = \partial \mathbf{h} / \partial \mathbf{x}$ is the measurement Jacobian.

\subsection{Bad Data Detection}

Normalized residuals identify bad measurements:
\begin{equation}
r_k^N = \frac{z_k - h_k(\hat{\mathbf{x}})}{\sigma_k \sqrt{\Omega_{kk}}}
\end{equation}

where $\Omega_{kk}$ is the residual sensitivity. If $|r_k^N| > \tau$ (typically 3.0), measurement $k$ is flagged.

% ============================================================================
\section{Contingency Analysis}
% ============================================================================

\subsection{N-1 Security Criterion}

The N-1 criterion requires the system to survive any single element outage without violating limits. Checking all $|\mathcal{E}|$ contingencies via full power flow is expensive.

\subsection{PTDF and LODF Factors}

\begin{definition}[Power Transfer Distribution Factor]
PTDF$_{\ell,n}$ = sensitivity of flow on branch $\ell$ to injection at bus $n$:
\begin{equation}
\text{PTDF}_{\ell,n} = \frac{\Delta P_\ell}{\Delta P_n}
\end{equation}
\end{definition}

\begin{definition}[Line Outage Distribution Factor]
LODF$_{\ell,m}$ = fraction of branch $m$'s flow redistributed to branch $\ell$ when $m$ trips:
\begin{equation}
\text{LODF}_{\ell,m} = \frac{P_\ell^{\text{post}} - P_\ell^{\text{pre}}}{P_m^{\text{pre}}}
\end{equation}
\end{definition}

The relationship between PTDF and LODF is:
\begin{equation}
\text{LODF}_{\ell,m} = \frac{\text{PTDF}_{\ell,i_m} - \text{PTDF}_{\ell,j_m}}{1 - (\text{PTDF}_{m,i_m} - \text{PTDF}_{m,j_m})}
\end{equation}

where $(i_m, j_m)$ are the terminal buses of branch $m$.

\subsection{Fast N-k Screening}

Given base case flows $P_\ell^0$ and LODF matrix, post-contingency flows are:
\begin{equation}
P_\ell^{\text{post}} = P_\ell^0 + \text{LODF}_{\ell,m} \cdot P_m^0
\end{equation}

This enables screening $O(|\mathcal{E}|^2)$ branch-to-branch contingencies in seconds rather than hours.

% ============================================================================
\part{Implementation and Benchmarks}
% ============================================================================

% ============================================================================
\section{Numerical Considerations}
% ============================================================================

\subsection{Floating-Point Precision}

Power system quantities span many orders of magnitude:
\begin{itemize}
    \item Voltage: 0.9--1.1 p.u. (well-conditioned)
    \item Angles: $\pm 30^\circ$ ($\pm 0.5$ rad)
    \item Impedances: $10^{-4}$--$10^{-1}$ p.u. (can cause ill-conditioning)
    \item Powers: $10^{-3}$--$10^3$ MW (wide range)
\end{itemize}

GAT uses \texttt{f64} (IEEE 754 double precision) throughout, providing:
\begin{itemize}
    \item 15-17 significant decimal digits
    \item Range: $\pm 10^{308}$
    \item Machine epsilon: $\epsilon_m \approx 2.2 \times 10^{-16}$
\end{itemize}

\subsection{Sparse Matrix Storage}

Y-bus matrices are sparse with $O(|\mathcal{E}|)$ non-zeros for $O(|\mathcal{N}|)$ rows/columns. GAT uses Compressed Sparse Column (CSC) format:

\begin{lstlisting}[language=Rust,caption={CSC matrix structure}]
struct CscMatrix {
    nrows: usize,
    ncols: usize,
    col_ptr: Vec<usize>,   // Column start indices
    row_idx: Vec<usize>,   // Row indices of non-zeros
    values: Vec<Complex64>, // Non-zero values
}
\end{lstlisting}

Benefits:
\begin{itemize}
    \item $O(1)$ column slicing for Y-bus $\times$ V multiplication
    \item Cache-friendly column-major traversal
    \item Standard format for CHOLMOD, UMFPACK, IPOPT
\end{itemize}

\subsection{Solver Tolerances}

\begin{table}[H]
\centering
\caption{Default Solver Tolerances}
\begin{tabular}{llll}
\toprule
Solver & Tolerance & Default & Purpose \\
\midrule
Newton-Raphson & $\|\mathbf{f}\|_\infty$ & $10^{-6}$ & Power mismatch \\
IPOPT & Dual infeasibility & $10^{-6}$ & KKT optimality \\
IPOPT & Constraint violation & $10^{-8}$ & Feasibility \\
Clarabel & Gap tolerance & $10^{-8}$ & Duality gap \\
\bottomrule
\end{tabular}
\end{table}

% ============================================================================
\section{Benchmark Results}
% ============================================================================

\subsection{Test Environment}

\begin{table}[H]
\centering
\caption{Benchmark System Configuration}
\begin{tabular}{ll}
\toprule
Component & Specification \\
\midrule
CPU & AMD Ryzen 9 5900X (12 cores, 24 threads) \\
Memory & 64 GB DDR4-3200 \\
OS & Ubuntu 22.04 LTS \\
Rust & 1.75.0 (stable) \\
IPOPT & 3.14.12 with MUMPS 5.5.1 \\
Clarabel & 0.9.0 \\
HiGHS & 1.7.0 \\
\bottomrule
\end{tabular}
\end{table}

\subsection{PGLib-OPF Validation}

\begin{table}[H]
\centering
\caption{AC-OPF Results on PGLib-OPF Benchmark (v23.07)}
\begin{tabular}{lrrrrr}
\toprule
Case & Buses & Gens & GAT Obj (\$/hr) & Ref Obj (\$/hr) & Gap \\
\midrule
case14\_ieee & 14 & 5 & 2,178.08 & 2,178.10 & \textbf{-0.00\%} \\
case30\_ieee & 30 & 6 & 8,081.52 & 8,081.53 & \textbf{-0.00\%} \\
case57\_ieee & 57 & 7 & 41,737.79 & 41,738.00 & \textbf{-0.00\%} \\
case118\_ieee & 118 & 54 & 97,213.61 & 97,214.00 & \textbf{-0.00\%} \\
case300\_ieee & 300 & 69 & 71,997.23 & 71,998.00 & \textbf{-0.00\%} \\
case1354\_pegase & 1,354 & 260 & 74,049.12 & 74,069.00 & \textbf{-0.03\%} \\
case2868\_rte & 2,868 & 596 & 79,773.91 & 79,795.00 & \textbf{-0.03\%} \\
case6515\_rte & 6,515 & 1,388 & 96,283.41 & 96,340.00 & \textbf{-0.06\%} \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Solver Comparison}

\begin{table}[H]
\centering
\caption{Solver Method Comparison (PGLib Suite, 68 Cases)}
\begin{tabular}{lrrrr}
\toprule
Method & Convergence & Mean Gap & Median Time & Max Size \\
\midrule
Economic Dispatch & 68/68 (100\%) & 18.3\% & 0.8 ms & 30,000 \\
DC-OPF (HiGHS) & 65/68 (96\%) & 6.2\% & 12 ms & 30,000 \\
SOCP (Clarabel) & 66/68 (97\%) & 4.2\% & 890 ms & 30,000 \\
AC-OPF (L-BFGS) & 65/68 (96\%) & 2.9\% & 4.2 s & 13,659 \\
AC-OPF (IPOPT) & 65/68 (96\%) & \textbf{0.02\%} & 1.8 s & 13,659 \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Convergence Profile}

For case118\_ieee with IPOPT:
\begin{itemize}
    \item Iterations: 23
    \item Final objective: \$97,213.61/hr
    \item Constraint violation: $< 10^{-10}$
    \item Dual infeasibility: $< 10^{-8}$
    \item Total time: 0.42 s
\end{itemize}

% ============================================================================
\section{Conclusion and Future Work}
% ============================================================================

GAT demonstrates that a single-binary, Rust-based power system toolkit can achieve industrial-grade accuracy while maintaining ease of deployment. The key contributions include:

\begin{enumerate}
    \item \textbf{Type-safe modeling}: Rust's type system prevents common bugs at compile time
    \item \textbf{Comprehensive solver hierarchy}: Four OPF methods with well-characterized tradeoffs
    \item \textbf{Analytical derivatives}: Full Jacobian and Hessian for IPOPT convergence
    \item \textbf{Dataset interoperability}: Unified handling of MATPOWER, PSS/E, CIM formats
    \item \textbf{Validated accuracy}: $<0.01\%$ gaps on standard benchmarks
\end{enumerate}

\subsection{Future Directions}

\begin{itemize}
    \item \textbf{Security-Constrained OPF (SCOPF)}: Incorporate N-1 constraints directly
    \item \textbf{Multi-Period Dispatch}: Storage, ramp constraints, rolling horizon
    \item \textbf{Distributed OPF}: ADMM decomposition for large networks
    \item \textbf{GPU Acceleration}: cuSPARSE for Y-bus operations
    \item \textbf{Learning-Augmented Warm-Start}: Neural network initialization
    \item \textbf{Stochastic OPF}: Chance constraints for renewable uncertainty
\end{itemize}

GAT is available under an open-source license at \url{https://github.com/monistowl/gat}.

% ============================================================================
\section*{Acknowledgments}
% ============================================================================

We thank the developers of MATPOWER, PowerModels.jl, PGLib-OPF, IPOPT, Clarabel, HiGHS, and petgraph for providing the foundational tools and test cases that enable rigorous validation of power system analysis software.

% ============================================================================
\bibliographystyle{plain}
\begin{thebibliography}{25}

\bibitem{carpentier1962contribution}
J.~Carpentier,
\newblock ``Contribution a l'etude du dispatching economique,''
\newblock \emph{Bulletin de la Societe Francaise des Electriciens}, vol.~8, no.~3, pp.~431--447, 1962.

\bibitem{zimmerman2011matpower}
R.~D. Zimmerman, C.~E. Murillo-Sanchez, and R.~J. Thomas,
\newblock ``{MATPOWER}: Steady-state operations, planning, and analysis tools for power systems research and education,''
\newblock \emph{IEEE Transactions on Power Systems}, vol.~26, no.~1, pp.~12--19, 2011.

\bibitem{coffrin2018powermodels}
C.~Coffrin, R.~Bent, K.~Sundar, Y.~Ng, and M.~Lubin,
\newblock ``{PowerModels.jl}: An open-source framework for exploring power flow formulations,''
\newblock in \emph{2018 Power Systems Computation Conference (PSCC)}, pp.~1--8, IEEE, 2018.

\bibitem{thurner2018pandapower}
L.~Thurner, A.~Scheidler, et~al.,
\newblock ``pandapower---an open-source Python tool for convenient modeling, analysis, and optimization of electric power systems,''
\newblock \emph{IEEE Transactions on Power Systems}, vol.~33, no.~6, pp.~6510--6521, 2018.

\bibitem{babaeinejadsarookolaee2019power}
S.~Babaeinejadsarookolaee et~al.,
\newblock ``The power grid library for benchmarking {AC} optimal power flow algorithms,''
\newblock arXiv preprint arXiv:1908.02788, 2019.

\bibitem{wachter2006implementation}
A.~Wachter and L.~T. Biegler,
\newblock ``On the implementation of an interior-point filter line-search algorithm for large-scale nonlinear programming,''
\newblock \emph{Mathematical Programming}, vol.~106, no.~1, pp.~25--57, 2006.

\bibitem{farivar2013branch}
M.~Farivar and S.~H. Low,
\newblock ``Branch flow model: Relaxations and convexification---Part I,''
\newblock \emph{IEEE Transactions on Power Systems}, vol.~28, no.~3, pp.~2554--2564, 2013.

\bibitem{gan2015exact}
L.~Gan, N.~Li, U.~Topcu, and S.~H. Low,
\newblock ``Exact convex relaxation of optimal power flow in radial networks,''
\newblock \emph{IEEE Transactions on Automatic Control}, vol.~60, no.~1, pp.~72--87, 2015.

\bibitem{low2014convex}
S.~H. Low,
\newblock ``Convex relaxation of optimal power flow---Part I: Formulations and equivalence,''
\newblock \emph{IEEE Transactions on Control of Network Systems}, vol.~1, no.~1, pp.~15--27, 2014.

\bibitem{goulart2024clarabel}
P.~J. Goulart and Y.~Chen,
\newblock ``Clarabel: An interior-point solver for conic programs with quadratic objectives,''
\newblock \emph{Optimization Methods and Software}, 2024.

\bibitem{liu1989limited}
D.~C. Liu and J.~Nocedal,
\newblock ``On the limited memory BFGS method for large scale optimization,''
\newblock \emph{Mathematical Programming}, vol.~45, no.~1, pp.~503--528, 1989.

\bibitem{abur2004power}
A.~Abur and A.~G. Exposito,
\newblock \emph{Power System State Estimation: Theory and Implementation},
\newblock CRC Press, 2004.

\bibitem{wood2013power}
A.~J. Wood, B.~F. Wollenberg, and G.~B. Sheble,
\newblock \emph{Power Generation, Operation, and Control},
\newblock John Wiley \& Sons, 3rd ed., 2013.

\bibitem{kundur1994power}
P.~Kundur,
\newblock \emph{Power System Stability and Control},
\newblock McGraw-Hill, 1994.

\bibitem{glover2012power}
J.~D. Glover, M.~S. Sarma, and T.~J. Overbye,
\newblock \emph{Power System Analysis and Design},
\newblock Cengage Learning, 5th ed., 2012.

\bibitem{tinney1967power}
W.~F. Tinney and C.~E. Hart,
\newblock ``Power flow solution by Newton's method,''
\newblock \emph{IEEE Transactions on Power Apparatus and Systems}, vol.~PAS-86, no.~11, pp.~1449--1460, 1967.

\bibitem{stott1974fast}
B.~Stott and O.~Alsac,
\newblock ``Fast decoupled load flow,''
\newblock \emph{IEEE Transactions on Power Apparatus and Systems}, vol.~93, no.~3, pp.~859--869, 1974.

\bibitem{capitanescu2011interior}
F.~Capitanescu et~al.,
\newblock ``State-of-the-art, challenges, and future trends in security constrained optimal power flow,''
\newblock \emph{Electric Power Systems Research}, vol.~81, no.~8, pp.~1731--1741, 2011.

\bibitem{molzahn2019survey}
D.~K. Molzahn and I.~A. Hiskens,
\newblock ``A survey of relaxations and approximations of the power flow equations,''
\newblock \emph{Foundations and Trends in Electric Energy Systems}, vol.~4, no.~1-2, pp.~1--221, 2019.

\bibitem{dommel1968optimal}
H.~W. Dommel and W.~F. Tinney,
\newblock ``Optimal power flow solutions,''
\newblock \emph{IEEE Transactions on Power Apparatus and Systems}, vol.~87, no.~10, pp.~1866--1876, 1968.

\end{thebibliography}

% ============================================================================
\appendix
\section{IPOPT Configuration}
% ============================================================================

Recommended IPOPT options for power system OPF:

\begin{lstlisting}[caption={IPOPT configuration for AC-OPF}]
# Barrier parameter
mu_strategy = adaptive
mu_init = 1e-4

# Tolerances
tol = 1e-6
constr_viol_tol = 1e-8
dual_inf_tol = 1e-6

# Linear solver (MUMPS recommended)
linear_solver = mumps

# Warm start
warm_start_init_point = yes
warm_start_bound_push = 1e-9
warm_start_mult_bound_push = 1e-9

# Output
print_level = 5
print_timing_statistics = yes
\end{lstlisting}

% ============================================================================
\section{CLI Reference}
% ============================================================================

\begin{lstlisting}[caption={GAT CLI examples}]
# Import MATPOWER case
gat import matpower --m case118.m -o case118.arrow

# Run DC-OPF
gat opf dc case118.arrow -o dc_results.parquet

# Run SOCP relaxation
gat opf socp case118.arrow -o socp_results.parquet

# Run AC-OPF with IPOPT
gat opf ac case118.arrow --solver ipopt -o ac_results.parquet

# State estimation
gat se case118.arrow --measurements meas.csv -o se_results.parquet

# N-1 contingency screening
gat contingency n1 case118.arrow -o contingency.parquet

# Benchmark against PGLib
gat benchmark pglib --pglib-dir pglib-opf -o results.csv
\end{lstlisting}

\end{document}
